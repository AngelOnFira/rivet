// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `GetDirectThread` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDirectThreadError {
	/// Kind of error that occurred.
	pub kind: GetDirectThreadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetDirectThread` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDirectThreadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDirectThreadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetDirectThreadErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetDirectThreadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetDirectThreadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetDirectThreadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetDirectThreadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetDirectThreadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetDirectThreadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDirectThreadError {
	fn code(&self) -> Option<&str> {
		GetDirectThreadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetDirectThreadErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetDirectThreadErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetDirectThreadError {
	/// Creates a new `GetDirectThreadError`.
	pub fn new(kind: GetDirectThreadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetDirectThreadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetDirectThreadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetDirectThreadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetDirectThreadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetDirectThreadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetDirectThreadErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetDirectThreadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetDirectThreadErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetDirectThreadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetDirectThreadErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetDirectThreadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetDirectThreadErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetDirectThreadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetDirectThreadErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetDirectThreadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetDirectThreadErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetDirectThreadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetDirectThreadErrorKind::InternalError(_inner) => Some(_inner),
			GetDirectThreadErrorKind::RateLimitError(_inner) => Some(_inner),
			GetDirectThreadErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetDirectThreadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetDirectThreadErrorKind::NotFoundError(_inner) => Some(_inner),
			GetDirectThreadErrorKind::BadRequestError(_inner) => Some(_inner),
			GetDirectThreadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetThreadHistory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetThreadHistoryError {
	/// Kind of error that occurred.
	pub kind: GetThreadHistoryErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetThreadHistory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetThreadHistoryErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetThreadHistoryError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetThreadHistoryErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetThreadHistoryErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetThreadHistoryErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetThreadHistoryErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetThreadHistoryErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetThreadHistoryErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetThreadHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetThreadHistoryError {
	fn code(&self) -> Option<&str> {
		GetThreadHistoryError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetThreadHistoryErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetThreadHistoryErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetThreadHistoryError {
	/// Creates a new `GetThreadHistoryError`.
	pub fn new(kind: GetThreadHistoryErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetThreadHistoryError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetThreadHistoryErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetThreadHistoryError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetThreadHistoryErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetThreadHistoryErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetThreadHistoryErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetThreadHistoryErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetThreadHistoryErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetThreadHistoryErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetThreadHistoryErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetThreadHistoryErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetThreadHistoryErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetThreadHistoryErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetThreadHistoryErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetThreadHistoryErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetThreadHistoryErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetThreadHistoryError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetThreadHistoryErrorKind::InternalError(_inner) => Some(_inner),
			GetThreadHistoryErrorKind::RateLimitError(_inner) => Some(_inner),
			GetThreadHistoryErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetThreadHistoryErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetThreadHistoryErrorKind::NotFoundError(_inner) => Some(_inner),
			GetThreadHistoryErrorKind::BadRequestError(_inner) => Some(_inner),
			GetThreadHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetThreadTopic` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetThreadTopicError {
	/// Kind of error that occurred.
	pub kind: GetThreadTopicErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetThreadTopic` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetThreadTopicErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetThreadTopicError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetThreadTopicErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetThreadTopicErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetThreadTopicErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetThreadTopicErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetThreadTopicErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetThreadTopicErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetThreadTopicErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetThreadTopicError {
	fn code(&self) -> Option<&str> {
		GetThreadTopicError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetThreadTopicErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetThreadTopicErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetThreadTopicError {
	/// Creates a new `GetThreadTopicError`.
	pub fn new(kind: GetThreadTopicErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetThreadTopicError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetThreadTopicErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetThreadTopicError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetThreadTopicErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetThreadTopicErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetThreadTopicErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetThreadTopicErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetThreadTopicErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetThreadTopicErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetThreadTopicErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetThreadTopicErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetThreadTopicErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetThreadTopicErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetThreadTopicErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetThreadTopicErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetThreadTopicErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetThreadTopicError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetThreadTopicErrorKind::InternalError(_inner) => Some(_inner),
			GetThreadTopicErrorKind::RateLimitError(_inner) => Some(_inner),
			GetThreadTopicErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetThreadTopicErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetThreadTopicErrorKind::NotFoundError(_inner) => Some(_inner),
			GetThreadTopicErrorKind::BadRequestError(_inner) => Some(_inner),
			GetThreadTopicErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SendChatMessage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendChatMessageError {
	/// Kind of error that occurred.
	pub kind: SendChatMessageErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SendChatMessage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendChatMessageErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendChatMessageError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SendChatMessageErrorKind::InternalError(_inner) => _inner.fmt(f),
			SendChatMessageErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SendChatMessageErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SendChatMessageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SendChatMessageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SendChatMessageErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SendChatMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SendChatMessageError {
	fn code(&self) -> Option<&str> {
		SendChatMessageError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SendChatMessageErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SendChatMessageErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl SendChatMessageError {
	/// Creates a new `SendChatMessageError`.
	pub fn new(kind: SendChatMessageErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SendChatMessageError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SendChatMessageErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SendChatMessageError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SendChatMessageErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SendChatMessageErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SendChatMessageErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SendChatMessageErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SendChatMessageErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SendChatMessageErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SendChatMessageErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SendChatMessageErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SendChatMessageErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SendChatMessageErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SendChatMessageErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SendChatMessageErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SendChatMessageErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SendChatMessageError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SendChatMessageErrorKind::InternalError(_inner) => Some(_inner),
			SendChatMessageErrorKind::RateLimitError(_inner) => Some(_inner),
			SendChatMessageErrorKind::ForbiddenError(_inner) => Some(_inner),
			SendChatMessageErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SendChatMessageErrorKind::NotFoundError(_inner) => Some(_inner),
			SendChatMessageErrorKind::BadRequestError(_inner) => Some(_inner),
			SendChatMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetThreadRead` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetThreadReadError {
	/// Kind of error that occurred.
	pub kind: SetThreadReadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetThreadRead` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetThreadReadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetThreadReadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetThreadReadErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetThreadReadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetThreadReadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetThreadReadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetThreadReadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetThreadReadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetThreadReadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetThreadReadError {
	fn code(&self) -> Option<&str> {
		SetThreadReadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetThreadReadErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SetThreadReadErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl SetThreadReadError {
	/// Creates a new `SetThreadReadError`.
	pub fn new(kind: SetThreadReadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetThreadReadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetThreadReadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetThreadReadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetThreadReadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetThreadReadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SetThreadReadErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SetThreadReadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SetThreadReadErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SetThreadReadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SetThreadReadErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SetThreadReadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SetThreadReadErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SetThreadReadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SetThreadReadErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SetThreadReadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SetThreadReadErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SetThreadReadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetThreadReadErrorKind::InternalError(_inner) => Some(_inner),
			SetThreadReadErrorKind::RateLimitError(_inner) => Some(_inner),
			SetThreadReadErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetThreadReadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetThreadReadErrorKind::NotFoundError(_inner) => Some(_inner),
			SetThreadReadErrorKind::BadRequestError(_inner) => Some(_inner),
			SetThreadReadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetTypingStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetTypingStatusError {
	/// Kind of error that occurred.
	pub kind: SetTypingStatusErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetTypingStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetTypingStatusErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetTypingStatusError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetTypingStatusErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetTypingStatusErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetTypingStatusErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetTypingStatusErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetTypingStatusErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetTypingStatusErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetTypingStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetTypingStatusError {
	fn code(&self) -> Option<&str> {
		SetTypingStatusError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetTypingStatusErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SetTypingStatusErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl SetTypingStatusError {
	/// Creates a new `SetTypingStatusError`.
	pub fn new(kind: SetTypingStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetTypingStatusError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetTypingStatusErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetTypingStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetTypingStatusErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetTypingStatusErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SetTypingStatusErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SetTypingStatusErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SetTypingStatusErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SetTypingStatusErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SetTypingStatusErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SetTypingStatusErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SetTypingStatusErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SetTypingStatusErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SetTypingStatusErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SetTypingStatusErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SetTypingStatusErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SetTypingStatusError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetTypingStatusErrorKind::InternalError(_inner) => Some(_inner),
			SetTypingStatusErrorKind::RateLimitError(_inner) => Some(_inner),
			SetTypingStatusErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetTypingStatusErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetTypingStatusErrorKind::NotFoundError(_inner) => Some(_inner),
			SetTypingStatusErrorKind::BadRequestError(_inner) => Some(_inner),
			SetTypingStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `WatchThread` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct WatchThreadError {
	/// Kind of error that occurred.
	pub kind: WatchThreadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `WatchThread` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum WatchThreadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existant resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for WatchThreadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			WatchThreadErrorKind::InternalError(_inner) => _inner.fmt(f),
			WatchThreadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			WatchThreadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			WatchThreadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			WatchThreadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			WatchThreadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			WatchThreadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for WatchThreadError {
	fn code(&self) -> Option<&str> {
		WatchThreadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			WatchThreadErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			WatchThreadErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl WatchThreadError {
	/// Creates a new `WatchThreadError`.
	pub fn new(kind: WatchThreadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `WatchThreadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: WatchThreadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `WatchThreadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: WatchThreadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `WatchThreadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, WatchThreadErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `WatchThreadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, WatchThreadErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `WatchThreadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, WatchThreadErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `WatchThreadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, WatchThreadErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `WatchThreadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, WatchThreadErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `WatchThreadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, WatchThreadErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for WatchThreadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			WatchThreadErrorKind::InternalError(_inner) => Some(_inner),
			WatchThreadErrorKind::RateLimitError(_inner) => Some(_inner),
			WatchThreadErrorKind::ForbiddenError(_inner) => Some(_inner),
			WatchThreadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			WatchThreadErrorKind::NotFoundError(_inner) => Some(_inner),
			WatchThreadErrorKind::BadRequestError(_inner) => Some(_inner),
			WatchThreadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// An error thrown when the requestee has sent an invalid or malformed request.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("BadRequestError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl BadRequestError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "BadRequestError")?;
		if let Some(inner_1) = &self.message {
			write!(f, ": {}", inner_1)?;
		}
		Ok(())
	}
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
	/// A builder for [`BadRequestError`](crate::error::BadRequestError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
		pub fn build(self) -> crate::error::BadRequestError {
			crate::error::BadRequestError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl BadRequestError {
	/// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
	pub fn builder() -> crate::error::bad_request_error::Builder {
		crate::error::bad_request_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a non existant resource.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("NotFoundError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl NotFoundError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "NotFoundError")?;
		if let Some(inner_2) = &self.message {
			write!(f, ": {}", inner_2)?;
		}
		Ok(())
	}
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
	/// A builder for [`NotFoundError`](crate::error::NotFoundError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
		pub fn build(self) -> crate::error::NotFoundError {
			crate::error::NotFoundError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl NotFoundError {
	/// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
	pub fn builder() -> crate::error::not_found_error::Builder {
		crate::error::not_found_error::Builder::default()
	}
}

/// An error thrown when the requestee is not authenticated.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnauthorizedError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl UnauthorizedError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ClientError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "UnauthorizedError")?;
		if let Some(inner_3) = &self.message {
			write!(f, ": {}", inner_3)?;
		}
		Ok(())
	}
}
impl std::error::Error for UnauthorizedError {}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError)
pub mod unauthorized_error {
	/// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError)
		pub fn build(self) -> crate::error::UnauthorizedError {
			crate::error::UnauthorizedError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl UnauthorizedError {
	/// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError)
	pub fn builder() -> crate::error::unauthorized_error::Builder {
		crate::error::unauthorized_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a resource they do not have access to.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ForbiddenError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl ForbiddenError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "ForbiddenError")?;
		if let Some(inner_4) = &self.message {
			write!(f, ": {}", inner_4)?;
		}
		Ok(())
	}
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
	/// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
		pub fn build(self) -> crate::error::ForbiddenError {
			crate::error::ForbiddenError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl ForbiddenError {
	/// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
	pub fn builder() -> crate::error::forbidden_error::Builder {
		crate::error::forbidden_error::Builder::default()
	}
}

/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RateLimitError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl RateLimitError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "RateLimitError")?;
		if let Some(inner_5) = &self.message {
			write!(f, ": {}", inner_5)?;
		}
		Ok(())
	}
}
impl std::error::Error for RateLimitError {}
/// See [`RateLimitError`](crate::error::RateLimitError)
pub mod rate_limit_error {
	/// A builder for [`RateLimitError`](crate::error::RateLimitError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`RateLimitError`](crate::error::RateLimitError)
		pub fn build(self) -> crate::error::RateLimitError {
			crate::error::RateLimitError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl RateLimitError {
	/// Creates a new builder-style object to manufacture [`RateLimitError`](crate::error::RateLimitError)
	pub fn builder() -> crate::error::rate_limit_error::Builder {
		crate::error::rate_limit_error::Builder::default()
	}
}

/// An error caused by internal server problems.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InternalError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl InternalError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ServerError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "InternalError")?;
		if let Some(inner_6) = &self.message {
			write!(f, ": {}", inner_6)?;
		}
		Ok(())
	}
}
impl std::error::Error for InternalError {}
/// See [`InternalError`](crate::error::InternalError)
pub mod internal_error {
	/// A builder for [`InternalError`](crate::error::InternalError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`InternalError`](crate::error::InternalError)
		pub fn build(self) -> crate::error::InternalError {
			crate::error::InternalError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl InternalError {
	/// Creates a new builder-style object to manufacture [`InternalError`](crate::error::InternalError)
	pub fn builder() -> crate::error::internal_error::Builder {
		crate::error::internal_error::Builder::default()
	}
}
