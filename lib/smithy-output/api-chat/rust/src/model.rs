// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// An identity handle.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityHandle {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
	pub account_number: std::option::Option<i32>,
	/// The URL of this identity's avatar image.
	pub avatar_url: std::option::Option<std::string::String>,
	/// Information about the identity's current status, party, and active game.
	pub presence: std::option::Option<crate::model::IdentityPresence>,
	/// A party handle.
	pub party: std::option::Option<crate::model::PartyHandle>,
	/// Whether or not this identity is registered with a linked account.
	pub is_registered: std::option::Option<bool>,
	/// External links for an identity.
	pub external: std::option::Option<crate::model::IdentityExternalLinks>,
}
impl IdentityHandle {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
	pub fn account_number(&self) -> std::option::Option<i32> {
		self.account_number
	}
	/// The URL of this identity's avatar image.
	pub fn avatar_url(&self) -> std::option::Option<&str> {
		self.avatar_url.as_deref()
	}
	/// Information about the identity's current status, party, and active game.
	pub fn presence(&self) -> std::option::Option<&crate::model::IdentityPresence> {
		self.presence.as_ref()
	}
	/// A party handle.
	pub fn party(&self) -> std::option::Option<&crate::model::PartyHandle> {
		self.party.as_ref()
	}
	/// Whether or not this identity is registered with a linked account.
	pub fn is_registered(&self) -> std::option::Option<bool> {
		self.is_registered
	}
	/// External links for an identity.
	pub fn external(&self) -> std::option::Option<&crate::model::IdentityExternalLinks> {
		self.external.as_ref()
	}
}
impl std::fmt::Debug for IdentityHandle {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("IdentityHandle");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("account_number", &self.account_number);
		formatter.field("avatar_url", &self.avatar_url);
		formatter.field("presence", &self.presence);
		formatter.field("party", &self.party);
		formatter.field("is_registered", &self.is_registered);
		formatter.field("external", &self.external);
		formatter.finish()
	}
}
/// See [`IdentityHandle`](crate::model::IdentityHandle)
pub mod identity_handle {
	/// A builder for [`IdentityHandle`](crate::model::IdentityHandle)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) account_number: std::option::Option<i32>,
		pub(crate) avatar_url: std::option::Option<std::string::String>,
		pub(crate) presence: std::option::Option<crate::model::IdentityPresence>,
		pub(crate) party: std::option::Option<crate::model::PartyHandle>,
		pub(crate) is_registered: std::option::Option<bool>,
		pub(crate) external: std::option::Option<crate::model::IdentityExternalLinks>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
		pub fn account_number(mut self, input: i32) -> Self {
			self.account_number = Some(input);
			self
		}
		/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
		pub fn set_account_number(mut self, input: std::option::Option<i32>) -> Self {
			self.account_number = input;
			self
		}
		/// The URL of this identity's avatar image.
		pub fn avatar_url(mut self, input: impl Into<std::string::String>) -> Self {
			self.avatar_url = Some(input.into());
			self
		}
		/// The URL of this identity's avatar image.
		pub fn set_avatar_url(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.avatar_url = input;
			self
		}
		/// Information about the identity's current status, party, and active game.
		pub fn presence(mut self, input: crate::model::IdentityPresence) -> Self {
			self.presence = Some(input);
			self
		}
		/// Information about the identity's current status, party, and active game.
		pub fn set_presence(
			mut self,
			input: std::option::Option<crate::model::IdentityPresence>,
		) -> Self {
			self.presence = input;
			self
		}
		/// A party handle.
		pub fn party(mut self, input: crate::model::PartyHandle) -> Self {
			self.party = Some(input);
			self
		}
		/// A party handle.
		pub fn set_party(mut self, input: std::option::Option<crate::model::PartyHandle>) -> Self {
			self.party = input;
			self
		}
		/// Whether or not this identity is registered with a linked account.
		pub fn is_registered(mut self, input: bool) -> Self {
			self.is_registered = Some(input);
			self
		}
		/// Whether or not this identity is registered with a linked account.
		pub fn set_is_registered(mut self, input: std::option::Option<bool>) -> Self {
			self.is_registered = input;
			self
		}
		/// External links for an identity.
		pub fn external(mut self, input: crate::model::IdentityExternalLinks) -> Self {
			self.external = Some(input);
			self
		}
		/// External links for an identity.
		pub fn set_external(
			mut self,
			input: std::option::Option<crate::model::IdentityExternalLinks>,
		) -> Self {
			self.external = input;
			self
		}
		/// Consumes the builder and constructs a [`IdentityHandle`](crate::model::IdentityHandle)
		pub fn build(self) -> crate::model::IdentityHandle {
			crate::model::IdentityHandle {
				identity_id: self.identity_id,
				display_name: self.display_name,
				account_number: self.account_number,
				avatar_url: self.avatar_url,
				presence: self.presence,
				party: self.party,
				is_registered: self.is_registered,
				external: self.external,
			}
		}
	}
}
impl IdentityHandle {
	/// Creates a new builder-style object to manufacture [`IdentityHandle`](crate::model::IdentityHandle)
	pub fn builder() -> crate::model::identity_handle::Builder {
		crate::model::identity_handle::Builder::default()
	}
}

/// External links for an identity.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityExternalLinks {
	/// A link to this identity's profile page.
	pub profile: std::option::Option<std::string::String>,
	/// A link to the Rivet settings page.
	pub settings: std::option::Option<std::string::String>,
	/// A link to a chat page with the given identity.
	pub chat: std::option::Option<std::string::String>,
}
impl IdentityExternalLinks {
	/// A link to this identity's profile page.
	pub fn profile(&self) -> std::option::Option<&str> {
		self.profile.as_deref()
	}
	/// A link to the Rivet settings page.
	pub fn settings(&self) -> std::option::Option<&str> {
		self.settings.as_deref()
	}
	/// A link to a chat page with the given identity.
	pub fn chat(&self) -> std::option::Option<&str> {
		self.chat.as_deref()
	}
}
impl std::fmt::Debug for IdentityExternalLinks {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("IdentityExternalLinks");
		formatter.field("profile", &self.profile);
		formatter.field("settings", &self.settings);
		formatter.field("chat", &self.chat);
		formatter.finish()
	}
}
/// See [`IdentityExternalLinks`](crate::model::IdentityExternalLinks)
pub mod identity_external_links {
	/// A builder for [`IdentityExternalLinks`](crate::model::IdentityExternalLinks)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) profile: std::option::Option<std::string::String>,
		pub(crate) settings: std::option::Option<std::string::String>,
		pub(crate) chat: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A link to this identity's profile page.
		pub fn profile(mut self, input: impl Into<std::string::String>) -> Self {
			self.profile = Some(input.into());
			self
		}
		/// A link to this identity's profile page.
		pub fn set_profile(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.profile = input;
			self
		}
		/// A link to the Rivet settings page.
		pub fn settings(mut self, input: impl Into<std::string::String>) -> Self {
			self.settings = Some(input.into());
			self
		}
		/// A link to the Rivet settings page.
		pub fn set_settings(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.settings = input;
			self
		}
		/// A link to a chat page with the given identity.
		pub fn chat(mut self, input: impl Into<std::string::String>) -> Self {
			self.chat = Some(input.into());
			self
		}
		/// A link to a chat page with the given identity.
		pub fn set_chat(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.chat = input;
			self
		}
		/// Consumes the builder and constructs a [`IdentityExternalLinks`](crate::model::IdentityExternalLinks)
		pub fn build(self) -> crate::model::IdentityExternalLinks {
			crate::model::IdentityExternalLinks {
				profile: self.profile,
				settings: self.settings,
				chat: self.chat,
			}
		}
	}
}
impl IdentityExternalLinks {
	/// Creates a new builder-style object to manufacture [`IdentityExternalLinks`](crate::model::IdentityExternalLinks)
	pub fn builder() -> crate::model::identity_external_links::Builder {
		crate::model::identity_external_links::Builder::default()
	}
}

/// A party handle.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartyHandle {
	/// A universally unique identifier.
	pub party_id: std::option::Option<std::string::String>,
	/// RFC3339 timestamp.
	pub create_ts: std::option::Option<aws_smithy_types::DateTime>,
	/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
	pub activity: std::option::Option<crate::model::PartyActivity>,
	/// External links for a party.
	pub external: std::option::Option<crate::model::PartyExternalLinks>,
}
impl PartyHandle {
	/// A universally unique identifier.
	pub fn party_id(&self) -> std::option::Option<&str> {
		self.party_id.as_deref()
	}
	/// RFC3339 timestamp.
	pub fn create_ts(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
		self.create_ts.as_ref()
	}
	/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
	pub fn activity(&self) -> std::option::Option<&crate::model::PartyActivity> {
		self.activity.as_ref()
	}
	/// External links for a party.
	pub fn external(&self) -> std::option::Option<&crate::model::PartyExternalLinks> {
		self.external.as_ref()
	}
}
impl std::fmt::Debug for PartyHandle {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PartyHandle");
		formatter.field("party_id", &self.party_id);
		formatter.field("create_ts", &self.create_ts);
		formatter.field("activity", &self.activity);
		formatter.field("external", &self.external);
		formatter.finish()
	}
}
/// See [`PartyHandle`](crate::model::PartyHandle)
pub mod party_handle {
	/// A builder for [`PartyHandle`](crate::model::PartyHandle)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) party_id: std::option::Option<std::string::String>,
		pub(crate) create_ts: std::option::Option<aws_smithy_types::DateTime>,
		pub(crate) activity: std::option::Option<crate::model::PartyActivity>,
		pub(crate) external: std::option::Option<crate::model::PartyExternalLinks>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn party_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.party_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_party_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.party_id = input;
			self
		}
		/// RFC3339 timestamp.
		pub fn create_ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.create_ts = Some(input);
			self
		}
		/// RFC3339 timestamp.
		pub fn set_create_ts(
			mut self,
			input: std::option::Option<aws_smithy_types::DateTime>,
		) -> Self {
			self.create_ts = input;
			self
		}
		/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
		pub fn activity(mut self, input: crate::model::PartyActivity) -> Self {
			self.activity = Some(input);
			self
		}
		/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
		pub fn set_activity(
			mut self,
			input: std::option::Option<crate::model::PartyActivity>,
		) -> Self {
			self.activity = input;
			self
		}
		/// External links for a party.
		pub fn external(mut self, input: crate::model::PartyExternalLinks) -> Self {
			self.external = Some(input);
			self
		}
		/// External links for a party.
		pub fn set_external(
			mut self,
			input: std::option::Option<crate::model::PartyExternalLinks>,
		) -> Self {
			self.external = input;
			self
		}
		/// Consumes the builder and constructs a [`PartyHandle`](crate::model::PartyHandle)
		pub fn build(self) -> crate::model::PartyHandle {
			crate::model::PartyHandle {
				party_id: self.party_id,
				create_ts: self.create_ts,
				activity: self.activity,
				external: self.external,
			}
		}
	}
}
impl PartyHandle {
	/// Creates a new builder-style object to manufacture [`PartyHandle`](crate::model::PartyHandle)
	pub fn builder() -> crate::model::party_handle::Builder {
		crate::model::party_handle::Builder::default()
	}
}

/// External links for a party.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartyExternalLinks {
	/// A link to the given party's chat thread.
	pub chat: std::option::Option<std::string::String>,
}
impl PartyExternalLinks {
	/// A link to the given party's chat thread.
	pub fn chat(&self) -> std::option::Option<&str> {
		self.chat.as_deref()
	}
}
impl std::fmt::Debug for PartyExternalLinks {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PartyExternalLinks");
		formatter.field("chat", &self.chat);
		formatter.finish()
	}
}
/// See [`PartyExternalLinks`](crate::model::PartyExternalLinks)
pub mod party_external_links {
	/// A builder for [`PartyExternalLinks`](crate::model::PartyExternalLinks)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) chat: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A link to the given party's chat thread.
		pub fn chat(mut self, input: impl Into<std::string::String>) -> Self {
			self.chat = Some(input.into());
			self
		}
		/// A link to the given party's chat thread.
		pub fn set_chat(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.chat = input;
			self
		}
		/// Consumes the builder and constructs a [`PartyExternalLinks`](crate::model::PartyExternalLinks)
		pub fn build(self) -> crate::model::PartyExternalLinks {
			crate::model::PartyExternalLinks { chat: self.chat }
		}
	}
}
impl PartyExternalLinks {
	/// Creates a new builder-style object to manufacture [`PartyExternalLinks`](crate::model::PartyExternalLinks)
	pub fn builder() -> crate::model::party_external_links::Builder {
		crate::model::party_external_links::Builder::default()
	}
}

/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum PartyActivity {
	/// A party activity denoting that the party is idle.
	Idle(crate::model::PartyActivityIdle),
	/// A party activity denoting that the party is currently searching for a lobby.
	MatchmakerFindingLobby(crate::model::PartyActivityMatchmakerFindingLobby),
	/// A party activity denoting that the party is currently in a lobby.
	MatchmakerLobby(crate::model::PartyActivityMatchmakerLobby),
	/// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
	/// An unknown enum variant
	///
	/// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
	/// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
	/// by the client. This can happen when the server adds new functionality, but the client has not been updated.
	/// To investigate this, consider turning on debug logging to print the raw HTTP response.
	#[non_exhaustive]
	Unknown,
}
impl PartyActivity {
	/// Tries to convert the enum instance into [`Idle`](crate::model::PartyActivity::Idle), extracting the inner [`PartyActivityIdle`](crate::model::PartyActivityIdle).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_idle(&self) -> std::result::Result<&crate::model::PartyActivityIdle, &Self> {
		if let PartyActivity::Idle(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Idle`](crate::model::PartyActivity::Idle).
	pub fn is_idle(&self) -> bool {
		self.as_idle().is_ok()
	}
	/// Tries to convert the enum instance into [`MatchmakerFindingLobby`](crate::model::PartyActivity::MatchmakerFindingLobby), extracting the inner [`PartyActivityMatchmakerFindingLobby`](crate::model::PartyActivityMatchmakerFindingLobby).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_matchmaker_finding_lobby(
		&self,
	) -> std::result::Result<&crate::model::PartyActivityMatchmakerFindingLobby, &Self> {
		if let PartyActivity::MatchmakerFindingLobby(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`MatchmakerFindingLobby`](crate::model::PartyActivity::MatchmakerFindingLobby).
	pub fn is_matchmaker_finding_lobby(&self) -> bool {
		self.as_matchmaker_finding_lobby().is_ok()
	}
	/// Tries to convert the enum instance into [`MatchmakerLobby`](crate::model::PartyActivity::MatchmakerLobby), extracting the inner [`PartyActivityMatchmakerLobby`](crate::model::PartyActivityMatchmakerLobby).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_matchmaker_lobby(
		&self,
	) -> std::result::Result<&crate::model::PartyActivityMatchmakerLobby, &Self> {
		if let PartyActivity::MatchmakerLobby(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`MatchmakerLobby`](crate::model::PartyActivity::MatchmakerLobby).
	pub fn is_matchmaker_lobby(&self) -> bool {
		self.as_matchmaker_lobby().is_ok()
	}
	/// Returns true if the enum instance is the `Unknown` variant.
	pub fn is_unknown(&self) -> bool {
		matches!(self, Self::Unknown)
	}
}

/// A party activity denoting that the party is currently in a lobby.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartyActivityMatchmakerLobby {
	/// A party lobby.
	pub lobby: std::option::Option<crate::model::PartyMatchmakerLobby>,
	/// A game handle.
	pub game: std::option::Option<crate::model::GameHandle>,
}
impl PartyActivityMatchmakerLobby {
	/// A party lobby.
	pub fn lobby(&self) -> std::option::Option<&crate::model::PartyMatchmakerLobby> {
		self.lobby.as_ref()
	}
	/// A game handle.
	pub fn game(&self) -> std::option::Option<&crate::model::GameHandle> {
		self.game.as_ref()
	}
}
impl std::fmt::Debug for PartyActivityMatchmakerLobby {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PartyActivityMatchmakerLobby");
		formatter.field("lobby", &self.lobby);
		formatter.field("game", &self.game);
		formatter.finish()
	}
}
/// See [`PartyActivityMatchmakerLobby`](crate::model::PartyActivityMatchmakerLobby)
pub mod party_activity_matchmaker_lobby {
	/// A builder for [`PartyActivityMatchmakerLobby`](crate::model::PartyActivityMatchmakerLobby)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) lobby: std::option::Option<crate::model::PartyMatchmakerLobby>,
		pub(crate) game: std::option::Option<crate::model::GameHandle>,
	}
	impl Builder {
		/// A party lobby.
		pub fn lobby(mut self, input: crate::model::PartyMatchmakerLobby) -> Self {
			self.lobby = Some(input);
			self
		}
		/// A party lobby.
		pub fn set_lobby(
			mut self,
			input: std::option::Option<crate::model::PartyMatchmakerLobby>,
		) -> Self {
			self.lobby = input;
			self
		}
		/// A game handle.
		pub fn game(mut self, input: crate::model::GameHandle) -> Self {
			self.game = Some(input);
			self
		}
		/// A game handle.
		pub fn set_game(mut self, input: std::option::Option<crate::model::GameHandle>) -> Self {
			self.game = input;
			self
		}
		/// Consumes the builder and constructs a [`PartyActivityMatchmakerLobby`](crate::model::PartyActivityMatchmakerLobby)
		pub fn build(self) -> crate::model::PartyActivityMatchmakerLobby {
			crate::model::PartyActivityMatchmakerLobby {
				lobby: self.lobby,
				game: self.game,
			}
		}
	}
}
impl PartyActivityMatchmakerLobby {
	/// Creates a new builder-style object to manufacture [`PartyActivityMatchmakerLobby`](crate::model::PartyActivityMatchmakerLobby)
	pub fn builder() -> crate::model::party_activity_matchmaker_lobby::Builder {
		crate::model::party_activity_matchmaker_lobby::Builder::default()
	}
}

/// A game handle.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GameHandle {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub name_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// The URL of this game's logo image.
	pub logo_url: std::option::Option<std::string::String>,
	/// The URL of this game's banner image.
	pub banner_url: std::option::Option<std::string::String>,
}
impl GameHandle {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// The URL of this game's logo image.
	pub fn logo_url(&self) -> std::option::Option<&str> {
		self.logo_url.as_deref()
	}
	/// The URL of this game's banner image.
	pub fn banner_url(&self) -> std::option::Option<&str> {
		self.banner_url.as_deref()
	}
}
impl std::fmt::Debug for GameHandle {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GameHandle");
		formatter.field("game_id", &self.game_id);
		formatter.field("name_id", &self.name_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("logo_url", &self.logo_url);
		formatter.field("banner_url", &self.banner_url);
		formatter.finish()
	}
}
/// See [`GameHandle`](crate::model::GameHandle)
pub mod game_handle {
	/// A builder for [`GameHandle`](crate::model::GameHandle)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) logo_url: std::option::Option<std::string::String>,
		pub(crate) banner_url: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// The URL of this game's logo image.
		pub fn logo_url(mut self, input: impl Into<std::string::String>) -> Self {
			self.logo_url = Some(input.into());
			self
		}
		/// The URL of this game's logo image.
		pub fn set_logo_url(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.logo_url = input;
			self
		}
		/// The URL of this game's banner image.
		pub fn banner_url(mut self, input: impl Into<std::string::String>) -> Self {
			self.banner_url = Some(input.into());
			self
		}
		/// The URL of this game's banner image.
		pub fn set_banner_url(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.banner_url = input;
			self
		}
		/// Consumes the builder and constructs a [`GameHandle`](crate::model::GameHandle)
		pub fn build(self) -> crate::model::GameHandle {
			crate::model::GameHandle {
				game_id: self.game_id,
				name_id: self.name_id,
				display_name: self.display_name,
				logo_url: self.logo_url,
				banner_url: self.banner_url,
			}
		}
	}
}
impl GameHandle {
	/// Creates a new builder-style object to manufacture [`GameHandle`](crate::model::GameHandle)
	pub fn builder() -> crate::model::game_handle::Builder {
		crate::model::game_handle::Builder::default()
	}
}

/// A party lobby.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartyMatchmakerLobby {
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
}
impl PartyMatchmakerLobby {
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
}
impl std::fmt::Debug for PartyMatchmakerLobby {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PartyMatchmakerLobby");
		formatter.field("lobby_id", &self.lobby_id);
		formatter.finish()
	}
}
/// See [`PartyMatchmakerLobby`](crate::model::PartyMatchmakerLobby)
pub mod party_matchmaker_lobby {
	/// A builder for [`PartyMatchmakerLobby`](crate::model::PartyMatchmakerLobby)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) lobby_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Consumes the builder and constructs a [`PartyMatchmakerLobby`](crate::model::PartyMatchmakerLobby)
		pub fn build(self) -> crate::model::PartyMatchmakerLobby {
			crate::model::PartyMatchmakerLobby {
				lobby_id: self.lobby_id,
			}
		}
	}
}
impl PartyMatchmakerLobby {
	/// Creates a new builder-style object to manufacture [`PartyMatchmakerLobby`](crate::model::PartyMatchmakerLobby)
	pub fn builder() -> crate::model::party_matchmaker_lobby::Builder {
		crate::model::party_matchmaker_lobby::Builder::default()
	}
}

/// A party activity denoting that the party is currently searching for a lobby.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartyActivityMatchmakerFindingLobby {
	/// A game handle.
	pub game: std::option::Option<crate::model::GameHandle>,
}
impl PartyActivityMatchmakerFindingLobby {
	/// A game handle.
	pub fn game(&self) -> std::option::Option<&crate::model::GameHandle> {
		self.game.as_ref()
	}
}
impl std::fmt::Debug for PartyActivityMatchmakerFindingLobby {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PartyActivityMatchmakerFindingLobby");
		formatter.field("game", &self.game);
		formatter.finish()
	}
}
/// See [`PartyActivityMatchmakerFindingLobby`](crate::model::PartyActivityMatchmakerFindingLobby)
pub mod party_activity_matchmaker_finding_lobby {
	/// A builder for [`PartyActivityMatchmakerFindingLobby`](crate::model::PartyActivityMatchmakerFindingLobby)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game: std::option::Option<crate::model::GameHandle>,
	}
	impl Builder {
		/// A game handle.
		pub fn game(mut self, input: crate::model::GameHandle) -> Self {
			self.game = Some(input);
			self
		}
		/// A game handle.
		pub fn set_game(mut self, input: std::option::Option<crate::model::GameHandle>) -> Self {
			self.game = input;
			self
		}
		/// Consumes the builder and constructs a [`PartyActivityMatchmakerFindingLobby`](crate::model::PartyActivityMatchmakerFindingLobby)
		pub fn build(self) -> crate::model::PartyActivityMatchmakerFindingLobby {
			crate::model::PartyActivityMatchmakerFindingLobby { game: self.game }
		}
	}
}
impl PartyActivityMatchmakerFindingLobby {
	/// Creates a new builder-style object to manufacture [`PartyActivityMatchmakerFindingLobby`](crate::model::PartyActivityMatchmakerFindingLobby)
	pub fn builder() -> crate::model::party_activity_matchmaker_finding_lobby::Builder {
		crate::model::party_activity_matchmaker_finding_lobby::Builder::default()
	}
}

/// A party activity denoting that the party is idle.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartyActivityIdle {}
impl std::fmt::Debug for PartyActivityIdle {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PartyActivityIdle");
		formatter.finish()
	}
}
/// See [`PartyActivityIdle`](crate::model::PartyActivityIdle)
pub mod party_activity_idle {
	/// A builder for [`PartyActivityIdle`](crate::model::PartyActivityIdle)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`PartyActivityIdle`](crate::model::PartyActivityIdle)
		pub fn build(self) -> crate::model::PartyActivityIdle {
			crate::model::PartyActivityIdle {}
		}
	}
}
impl PartyActivityIdle {
	/// Creates a new builder-style object to manufacture [`PartyActivityIdle`](crate::model::PartyActivityIdle)
	pub fn builder() -> crate::model::party_activity_idle::Builder {
		crate::model::party_activity_idle::Builder::default()
	}
}

/// Information about the identity's current status, party, and active game.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityPresence {
	/// RFC3339 timestamp.
	pub update_ts: std::option::Option<aws_smithy_types::DateTime>,
	/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
	pub status: std::option::Option<crate::model::IdentityStatus>,
	/// The game an identity is currently participating in.
	pub game_activity: std::option::Option<crate::model::IdentityGameActivity>,
}
impl IdentityPresence {
	/// RFC3339 timestamp.
	pub fn update_ts(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
		self.update_ts.as_ref()
	}
	/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
	pub fn status(&self) -> std::option::Option<&crate::model::IdentityStatus> {
		self.status.as_ref()
	}
	/// The game an identity is currently participating in.
	pub fn game_activity(&self) -> std::option::Option<&crate::model::IdentityGameActivity> {
		self.game_activity.as_ref()
	}
}
impl std::fmt::Debug for IdentityPresence {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("IdentityPresence");
		formatter.field("update_ts", &self.update_ts);
		formatter.field("status", &self.status);
		formatter.field("game_activity", &self.game_activity);
		formatter.finish()
	}
}
/// See [`IdentityPresence`](crate::model::IdentityPresence)
pub mod identity_presence {
	/// A builder for [`IdentityPresence`](crate::model::IdentityPresence)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) update_ts: std::option::Option<aws_smithy_types::DateTime>,
		pub(crate) status: std::option::Option<crate::model::IdentityStatus>,
		pub(crate) game_activity: std::option::Option<crate::model::IdentityGameActivity>,
	}
	impl Builder {
		/// RFC3339 timestamp.
		pub fn update_ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.update_ts = Some(input);
			self
		}
		/// RFC3339 timestamp.
		pub fn set_update_ts(
			mut self,
			input: std::option::Option<aws_smithy_types::DateTime>,
		) -> Self {
			self.update_ts = input;
			self
		}
		/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
		pub fn status(mut self, input: crate::model::IdentityStatus) -> Self {
			self.status = Some(input);
			self
		}
		/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
		pub fn set_status(
			mut self,
			input: std::option::Option<crate::model::IdentityStatus>,
		) -> Self {
			self.status = input;
			self
		}
		/// The game an identity is currently participating in.
		pub fn game_activity(mut self, input: crate::model::IdentityGameActivity) -> Self {
			self.game_activity = Some(input);
			self
		}
		/// The game an identity is currently participating in.
		pub fn set_game_activity(
			mut self,
			input: std::option::Option<crate::model::IdentityGameActivity>,
		) -> Self {
			self.game_activity = input;
			self
		}
		/// Consumes the builder and constructs a [`IdentityPresence`](crate::model::IdentityPresence)
		pub fn build(self) -> crate::model::IdentityPresence {
			crate::model::IdentityPresence {
				update_ts: self.update_ts,
				status: self.status,
				game_activity: self.game_activity,
			}
		}
	}
}
impl IdentityPresence {
	/// Creates a new builder-style object to manufacture [`IdentityPresence`](crate::model::IdentityPresence)
	pub fn builder() -> crate::model::identity_presence::Builder {
		crate::model::identity_presence::Builder::default()
	}
}

/// The game an identity is currently participating in.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityGameActivity {
	/// A game handle.
	pub game: std::option::Option<crate::model::GameHandle>,
	/// A short activity message about the current game activity.
	pub message: std::option::Option<std::string::String>,
	/// JSON data seen by anyone.
	pub public_metadata: std::option::Option<aws_smithy_types::Document>,
	/// JSON data seen only by the given identity and their mutual followers.
	pub mutual_metadata: std::option::Option<aws_smithy_types::Document>,
}
impl IdentityGameActivity {
	/// A game handle.
	pub fn game(&self) -> std::option::Option<&crate::model::GameHandle> {
		self.game.as_ref()
	}
	/// A short activity message about the current game activity.
	pub fn message(&self) -> std::option::Option<&str> {
		self.message.as_deref()
	}
	/// JSON data seen by anyone.
	pub fn public_metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.public_metadata.as_ref()
	}
	/// JSON data seen only by the given identity and their mutual followers.
	pub fn mutual_metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.mutual_metadata.as_ref()
	}
}
impl std::fmt::Debug for IdentityGameActivity {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("IdentityGameActivity");
		formatter.field("game", &self.game);
		formatter.field("message", &self.message);
		formatter.field("public_metadata", &self.public_metadata);
		formatter.field("mutual_metadata", &self.mutual_metadata);
		formatter.finish()
	}
}
/// See [`IdentityGameActivity`](crate::model::IdentityGameActivity)
pub mod identity_game_activity {
	/// A builder for [`IdentityGameActivity`](crate::model::IdentityGameActivity)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game: std::option::Option<crate::model::GameHandle>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) public_metadata: std::option::Option<aws_smithy_types::Document>,
		pub(crate) mutual_metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		/// A game handle.
		pub fn game(mut self, input: crate::model::GameHandle) -> Self {
			self.game = Some(input);
			self
		}
		/// A game handle.
		pub fn set_game(mut self, input: std::option::Option<crate::model::GameHandle>) -> Self {
			self.game = input;
			self
		}
		/// A short activity message about the current game activity.
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		/// A short activity message about the current game activity.
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		/// JSON data seen by anyone.
		pub fn public_metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.public_metadata = Some(input);
			self
		}
		/// JSON data seen by anyone.
		pub fn set_public_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.public_metadata = input;
			self
		}
		/// JSON data seen only by the given identity and their mutual followers.
		pub fn mutual_metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.mutual_metadata = Some(input);
			self
		}
		/// JSON data seen only by the given identity and their mutual followers.
		pub fn set_mutual_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.mutual_metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`IdentityGameActivity`](crate::model::IdentityGameActivity)
		pub fn build(self) -> crate::model::IdentityGameActivity {
			crate::model::IdentityGameActivity {
				game: self.game,
				message: self.message,
				public_metadata: self.public_metadata,
				mutual_metadata: self.mutual_metadata,
			}
		}
	}
}
impl IdentityGameActivity {
	/// Creates a new builder-style object to manufacture [`IdentityGameActivity`](crate::model::IdentityGameActivity)
	pub fn builder() -> crate::model::identity_game_activity::Builder {
		crate::model::identity_game_activity::Builder::default()
	}
}

/// The current status of an identity. This helps players understand if another
/// player is currently playing or has their game in the background.
#[non_exhaustive]
#[derive(
	std::clone::Clone,
	std::cmp::Eq,
	std::cmp::Ord,
	std::cmp::PartialEq,
	std::cmp::PartialOrd,
	std::fmt::Debug,
	std::hash::Hash,
)]
pub enum IdentityStatus {
	#[allow(missing_docs)] // documentation missing in model
	Away,
	#[allow(missing_docs)] // documentation missing in model
	Offline,
	#[allow(missing_docs)] // documentation missing in model
	Online,
	/// Unknown contains new variants that have been added since this code was generated.
	Unknown(String),
}
impl std::convert::From<&str> for IdentityStatus {
	fn from(s: &str) -> Self {
		match s {
			"away" => IdentityStatus::Away,
			"offline" => IdentityStatus::Offline,
			"online" => IdentityStatus::Online,
			other => IdentityStatus::Unknown(other.to_owned()),
		}
	}
}
impl std::str::FromStr for IdentityStatus {
	type Err = std::convert::Infallible;

	fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
		Ok(IdentityStatus::from(s))
	}
}
impl IdentityStatus {
	/// Returns the `&str` value of the enum member.
	pub fn as_str(&self) -> &str {
		match self {
			IdentityStatus::Away => "away",
			IdentityStatus::Offline => "offline",
			IdentityStatus::Online => "online",
			IdentityStatus::Unknown(s) => s.as_ref(),
		}
	}
	/// Returns all the `&str` values of the enum members.
	pub fn values() -> &'static [&'static str] {
		&["away", "offline", "online"]
	}
}
impl AsRef<str> for IdentityStatus {
	fn as_ref(&self) -> &str {
		self.as_str()
	}
}

/// Data to send in a chat message.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum SendMessageBody {
	/// `SendMessageBody` variant for party invite messages. Cannot send to party topics.
	PartyInvite(crate::model::SendMessageBodyPartyInvite),
	/// `rivet.api.chat.common#SendMessageBody` variant for text messages.
	Text(crate::model::SendMessageBodyText),
	/// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
	/// An unknown enum variant
	///
	/// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
	/// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
	/// by the client. This can happen when the server adds new functionality, but the client has not been updated.
	/// To investigate this, consider turning on debug logging to print the raw HTTP response.
	#[non_exhaustive]
	Unknown,
}
impl SendMessageBody {
	/// Tries to convert the enum instance into [`PartyInvite`](crate::model::SendMessageBody::PartyInvite), extracting the inner [`SendMessageBodyPartyInvite`](crate::model::SendMessageBodyPartyInvite).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_invite(
		&self,
	) -> std::result::Result<&crate::model::SendMessageBodyPartyInvite, &Self> {
		if let SendMessageBody::PartyInvite(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyInvite`](crate::model::SendMessageBody::PartyInvite).
	pub fn is_party_invite(&self) -> bool {
		self.as_party_invite().is_ok()
	}
	/// Tries to convert the enum instance into [`Text`](crate::model::SendMessageBody::Text), extracting the inner [`SendMessageBodyText`](crate::model::SendMessageBodyText).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_text(&self) -> std::result::Result<&crate::model::SendMessageBodyText, &Self> {
		if let SendMessageBody::Text(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Text`](crate::model::SendMessageBody::Text).
	pub fn is_text(&self) -> bool {
		self.as_text().is_ok()
	}
	/// Returns true if the enum instance is the `Unknown` variant.
	pub fn is_unknown(&self) -> bool {
		matches!(self, Self::Unknown)
	}
}

/// `SendMessageBody` variant for party invite messages. Cannot send to party topics.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendMessageBodyPartyInvite {
	/// An invite token.
	pub token: std::option::Option<std::string::String>,
}
impl SendMessageBodyPartyInvite {
	/// An invite token.
	pub fn token(&self) -> std::option::Option<&str> {
		self.token.as_deref()
	}
}
impl std::fmt::Debug for SendMessageBodyPartyInvite {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SendMessageBodyPartyInvite");
		formatter.field("token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}
/// See [`SendMessageBodyPartyInvite`](crate::model::SendMessageBodyPartyInvite)
pub mod send_message_body_party_invite {
	/// A builder for [`SendMessageBodyPartyInvite`](crate::model::SendMessageBodyPartyInvite)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// An invite token.
		pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
			self.token = Some(input.into());
			self
		}
		/// An invite token.
		pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.token = input;
			self
		}
		/// Consumes the builder and constructs a [`SendMessageBodyPartyInvite`](crate::model::SendMessageBodyPartyInvite)
		pub fn build(self) -> crate::model::SendMessageBodyPartyInvite {
			crate::model::SendMessageBodyPartyInvite { token: self.token }
		}
	}
}
impl SendMessageBodyPartyInvite {
	/// Creates a new builder-style object to manufacture [`SendMessageBodyPartyInvite`](crate::model::SendMessageBodyPartyInvite)
	pub fn builder() -> crate::model::send_message_body_party_invite::Builder {
		crate::model::send_message_body_party_invite::Builder::default()
	}
}

/// `rivet.api.chat.common#SendMessageBody` variant for text messages.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendMessageBodyText {
	#[allow(missing_docs)] // documentation missing in model
	pub body: std::option::Option<std::string::String>,
}
impl SendMessageBodyText {
	#[allow(missing_docs)] // documentation missing in model
	pub fn body(&self) -> std::option::Option<&str> {
		self.body.as_deref()
	}
}
impl std::fmt::Debug for SendMessageBodyText {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SendMessageBodyText");
		formatter.field("body", &self.body);
		formatter.finish()
	}
}
/// See [`SendMessageBodyText`](crate::model::SendMessageBodyText)
pub mod send_message_body_text {
	/// A builder for [`SendMessageBodyText`](crate::model::SendMessageBodyText)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) body: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
			self.body = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.body = input;
			self
		}
		/// Consumes the builder and constructs a [`SendMessageBodyText`](crate::model::SendMessageBodyText)
		pub fn build(self) -> crate::model::SendMessageBodyText {
			crate::model::SendMessageBodyText { body: self.body }
		}
	}
}
impl SendMessageBodyText {
	/// Creates a new builder-style object to manufacture [`SendMessageBodyText`](crate::model::SendMessageBodyText)
	pub fn builder() -> crate::model::send_message_body_text::Builder {
		crate::model::send_message_body_text::Builder::default()
	}
}

/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum SendChatTopic {
	/// A universally unique identifier.
	GroupId(std::string::String),
	/// A universally unique identifier.
	IdentityId(std::string::String),
	/// A universally unique identifier.
	PartyId(std::string::String),
	/// A universally unique identifier.
	ThreadId(std::string::String),
	/// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
	/// An unknown enum variant
	///
	/// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
	/// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
	/// by the client. This can happen when the server adds new functionality, but the client has not been updated.
	/// To investigate this, consider turning on debug logging to print the raw HTTP response.
	#[non_exhaustive]
	Unknown,
}
impl SendChatTopic {
	/// Tries to convert the enum instance into [`GroupId`](crate::model::SendChatTopic::GroupId), extracting the inner [`String`](std::string::String).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_group_id(&self) -> std::result::Result<&std::string::String, &Self> {
		if let SendChatTopic::GroupId(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`GroupId`](crate::model::SendChatTopic::GroupId).
	pub fn is_group_id(&self) -> bool {
		self.as_group_id().is_ok()
	}
	/// Tries to convert the enum instance into [`IdentityId`](crate::model::SendChatTopic::IdentityId), extracting the inner [`String`](std::string::String).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_identity_id(&self) -> std::result::Result<&std::string::String, &Self> {
		if let SendChatTopic::IdentityId(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`IdentityId`](crate::model::SendChatTopic::IdentityId).
	pub fn is_identity_id(&self) -> bool {
		self.as_identity_id().is_ok()
	}
	/// Tries to convert the enum instance into [`PartyId`](crate::model::SendChatTopic::PartyId), extracting the inner [`String`](std::string::String).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_id(&self) -> std::result::Result<&std::string::String, &Self> {
		if let SendChatTopic::PartyId(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyId`](crate::model::SendChatTopic::PartyId).
	pub fn is_party_id(&self) -> bool {
		self.as_party_id().is_ok()
	}
	/// Tries to convert the enum instance into [`ThreadId`](crate::model::SendChatTopic::ThreadId), extracting the inner [`String`](std::string::String).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_thread_id(&self) -> std::result::Result<&std::string::String, &Self> {
		if let SendChatTopic::ThreadId(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`ThreadId`](crate::model::SendChatTopic::ThreadId).
	pub fn is_thread_id(&self) -> bool {
		self.as_thread_id().is_ok()
	}
	/// Returns true if the enum instance is the `Unknown` variant.
	pub fn is_unknown(&self) -> bool {
		matches!(self, Self::Unknown)
	}
}

/// Represents a chat typing status.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ChatTypingStatus {
	/// Not typing.
	Idle(crate::model::Unit),
	/// Typing.
	Typing(crate::model::Unit),
	/// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
	/// An unknown enum variant
	///
	/// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
	/// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
	/// by the client. This can happen when the server adds new functionality, but the client has not been updated.
	/// To investigate this, consider turning on debug logging to print the raw HTTP response.
	#[non_exhaustive]
	Unknown,
}
impl ChatTypingStatus {
	/// Tries to convert the enum instance into [`Idle`](crate::model::ChatTypingStatus::Idle), extracting the inner [`Unit`](crate::model::Unit).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_idle(&self) -> std::result::Result<&crate::model::Unit, &Self> {
		if let ChatTypingStatus::Idle(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Idle`](crate::model::ChatTypingStatus::Idle).
	pub fn is_idle(&self) -> bool {
		self.as_idle().is_ok()
	}
	/// Tries to convert the enum instance into [`Typing`](crate::model::ChatTypingStatus::Typing), extracting the inner [`Unit`](crate::model::Unit).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_typing(&self) -> std::result::Result<&crate::model::Unit, &Self> {
		if let ChatTypingStatus::Typing(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Typing`](crate::model::ChatTypingStatus::Typing).
	pub fn is_typing(&self) -> bool {
		self.as_typing().is_ok()
	}
	/// Returns true if the enum instance is the `Unknown` variant.
	pub fn is_unknown(&self) -> bool {
		matches!(self, Self::Unknown)
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Unit {}
impl std::fmt::Debug for Unit {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("Unit");
		formatter.finish()
	}
}
/// See [`Unit`](crate::model::Unit)
pub mod unit {
	/// A builder for [`Unit`](crate::model::Unit)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`Unit`](crate::model::Unit)
		pub fn build(self) -> crate::model::Unit {
			crate::model::Unit {}
		}
	}
}
impl Unit {
	/// Creates a new builder-style object to manufacture [`Unit`](crate::model::Unit)
	pub fn builder() -> crate::model::unit::Builder {
		crate::model::unit::Builder::default()
	}
}

/// A chat message.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessage {
	/// A universally unique identifier.
	pub chat_message_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub thread_id: std::option::Option<std::string::String>,
	/// RFC3339 timestamp.
	pub send_ts: std::option::Option<aws_smithy_types::DateTime>,
	/// Represents types of chat message bodies.
	pub body: std::option::Option<crate::model::ChatMessageBody>,
}
impl ChatMessage {
	/// A universally unique identifier.
	pub fn chat_message_id(&self) -> std::option::Option<&str> {
		self.chat_message_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn thread_id(&self) -> std::option::Option<&str> {
		self.thread_id.as_deref()
	}
	/// RFC3339 timestamp.
	pub fn send_ts(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
		self.send_ts.as_ref()
	}
	/// Represents types of chat message bodies.
	pub fn body(&self) -> std::option::Option<&crate::model::ChatMessageBody> {
		self.body.as_ref()
	}
}
impl std::fmt::Debug for ChatMessage {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessage");
		formatter.field("chat_message_id", &self.chat_message_id);
		formatter.field("thread_id", &self.thread_id);
		formatter.field("send_ts", &self.send_ts);
		formatter.field("body", &self.body);
		formatter.finish()
	}
}
/// See [`ChatMessage`](crate::model::ChatMessage)
pub mod chat_message {
	/// A builder for [`ChatMessage`](crate::model::ChatMessage)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) chat_message_id: std::option::Option<std::string::String>,
		pub(crate) thread_id: std::option::Option<std::string::String>,
		pub(crate) send_ts: std::option::Option<aws_smithy_types::DateTime>,
		pub(crate) body: std::option::Option<crate::model::ChatMessageBody>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn chat_message_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.chat_message_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_chat_message_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.chat_message_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.thread_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.thread_id = input;
			self
		}
		/// RFC3339 timestamp.
		pub fn send_ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.send_ts = Some(input);
			self
		}
		/// RFC3339 timestamp.
		pub fn set_send_ts(
			mut self,
			input: std::option::Option<aws_smithy_types::DateTime>,
		) -> Self {
			self.send_ts = input;
			self
		}
		/// Represents types of chat message bodies.
		pub fn body(mut self, input: crate::model::ChatMessageBody) -> Self {
			self.body = Some(input);
			self
		}
		/// Represents types of chat message bodies.
		pub fn set_body(
			mut self,
			input: std::option::Option<crate::model::ChatMessageBody>,
		) -> Self {
			self.body = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessage`](crate::model::ChatMessage)
		pub fn build(self) -> crate::model::ChatMessage {
			crate::model::ChatMessage {
				chat_message_id: self.chat_message_id,
				thread_id: self.thread_id,
				send_ts: self.send_ts,
				body: self.body,
			}
		}
	}
}
impl ChatMessage {
	/// Creates a new builder-style object to manufacture [`ChatMessage`](crate::model::ChatMessage)
	pub fn builder() -> crate::model::chat_message::Builder {
		crate::model::chat_message::Builder::default()
	}
}

/// Represents types of chat message bodies.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ChatMessageBody {
	/// `rivet.chat#ChatMessageBody` variant for indicating a new chat was created.
	ChatCreate(crate::model::ChatMessageBodyChatCreate),
	/// `rivet.chat#ChatMessageBody` variant for deleted messages.
	Deleted(crate::model::ChatMessageBodyDeleted),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity joined the group.
	GroupJoin(crate::model::ChatMessageBodyGroupJoin),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity left the group.
	GroupLeave(crate::model::ChatMessageBodyGroupLeave),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity has been kicked from the group.
	GroupMemberKick(crate::model::ChatMessageBodyGroupMemberKick),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity followed the identity.
	IdentityFollow(crate::model::ChatMessageBodyIdentityFollow),
	/// `rivet.chat#ChatMessageBody` variant for indicating a change in the party's current activity.
	PartyActivityChange(crate::model::ChatMessageBodyPartyActivityChange),
	/// `rivet.chat#ChatMessageBody` variant holding an a party invitation.
	PartyInvite(crate::model::ChatMessageBodyPartyInvite),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity joined the party.
	PartyJoin(crate::model::ChatMessageBodyPartyJoin),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity requesting to join your party.
	PartyJoinRequest(crate::model::ChatMessageBodyPartyJoinRequest),
	/// `rivet.chat#ChatMessageBody` variant for indicating an identity left the party.
	PartyLeave(crate::model::ChatMessageBodyPartyLeave),
	/// `rivet.chat#ChatMessageBody` variant for text messages. Sent by other identities using the chat interface.
	Text(crate::model::ChatMessageBodyText),
	/// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
	/// An unknown enum variant
	///
	/// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
	/// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
	/// by the client. This can happen when the server adds new functionality, but the client has not been updated.
	/// To investigate this, consider turning on debug logging to print the raw HTTP response.
	#[non_exhaustive]
	Unknown,
}
impl ChatMessageBody {
	/// Tries to convert the enum instance into [`ChatCreate`](crate::model::ChatMessageBody::ChatCreate), extracting the inner [`ChatMessageBodyChatCreate`](crate::model::ChatMessageBodyChatCreate).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_chat_create(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyChatCreate, &Self> {
		if let ChatMessageBody::ChatCreate(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`ChatCreate`](crate::model::ChatMessageBody::ChatCreate).
	pub fn is_chat_create(&self) -> bool {
		self.as_chat_create().is_ok()
	}
	/// Tries to convert the enum instance into [`Deleted`](crate::model::ChatMessageBody::Deleted), extracting the inner [`ChatMessageBodyDeleted`](crate::model::ChatMessageBodyDeleted).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_deleted(&self) -> std::result::Result<&crate::model::ChatMessageBodyDeleted, &Self> {
		if let ChatMessageBody::Deleted(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Deleted`](crate::model::ChatMessageBody::Deleted).
	pub fn is_deleted(&self) -> bool {
		self.as_deleted().is_ok()
	}
	/// Tries to convert the enum instance into [`GroupJoin`](crate::model::ChatMessageBody::GroupJoin), extracting the inner [`ChatMessageBodyGroupJoin`](crate::model::ChatMessageBodyGroupJoin).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_group_join(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyGroupJoin, &Self> {
		if let ChatMessageBody::GroupJoin(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`GroupJoin`](crate::model::ChatMessageBody::GroupJoin).
	pub fn is_group_join(&self) -> bool {
		self.as_group_join().is_ok()
	}
	/// Tries to convert the enum instance into [`GroupLeave`](crate::model::ChatMessageBody::GroupLeave), extracting the inner [`ChatMessageBodyGroupLeave`](crate::model::ChatMessageBodyGroupLeave).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_group_leave(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyGroupLeave, &Self> {
		if let ChatMessageBody::GroupLeave(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`GroupLeave`](crate::model::ChatMessageBody::GroupLeave).
	pub fn is_group_leave(&self) -> bool {
		self.as_group_leave().is_ok()
	}
	/// Tries to convert the enum instance into [`GroupMemberKick`](crate::model::ChatMessageBody::GroupMemberKick), extracting the inner [`ChatMessageBodyGroupMemberKick`](crate::model::ChatMessageBodyGroupMemberKick).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_group_member_kick(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyGroupMemberKick, &Self> {
		if let ChatMessageBody::GroupMemberKick(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`GroupMemberKick`](crate::model::ChatMessageBody::GroupMemberKick).
	pub fn is_group_member_kick(&self) -> bool {
		self.as_group_member_kick().is_ok()
	}
	/// Tries to convert the enum instance into [`IdentityFollow`](crate::model::ChatMessageBody::IdentityFollow), extracting the inner [`ChatMessageBodyIdentityFollow`](crate::model::ChatMessageBodyIdentityFollow).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_identity_follow(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyIdentityFollow, &Self> {
		if let ChatMessageBody::IdentityFollow(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`IdentityFollow`](crate::model::ChatMessageBody::IdentityFollow).
	pub fn is_identity_follow(&self) -> bool {
		self.as_identity_follow().is_ok()
	}
	/// Tries to convert the enum instance into [`PartyActivityChange`](crate::model::ChatMessageBody::PartyActivityChange), extracting the inner [`ChatMessageBodyPartyActivityChange`](crate::model::ChatMessageBodyPartyActivityChange).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_activity_change(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyPartyActivityChange, &Self> {
		if let ChatMessageBody::PartyActivityChange(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyActivityChange`](crate::model::ChatMessageBody::PartyActivityChange).
	pub fn is_party_activity_change(&self) -> bool {
		self.as_party_activity_change().is_ok()
	}
	/// Tries to convert the enum instance into [`PartyInvite`](crate::model::ChatMessageBody::PartyInvite), extracting the inner [`ChatMessageBodyPartyInvite`](crate::model::ChatMessageBodyPartyInvite).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_invite(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyPartyInvite, &Self> {
		if let ChatMessageBody::PartyInvite(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyInvite`](crate::model::ChatMessageBody::PartyInvite).
	pub fn is_party_invite(&self) -> bool {
		self.as_party_invite().is_ok()
	}
	/// Tries to convert the enum instance into [`PartyJoin`](crate::model::ChatMessageBody::PartyJoin), extracting the inner [`ChatMessageBodyPartyJoin`](crate::model::ChatMessageBodyPartyJoin).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_join(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyPartyJoin, &Self> {
		if let ChatMessageBody::PartyJoin(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyJoin`](crate::model::ChatMessageBody::PartyJoin).
	pub fn is_party_join(&self) -> bool {
		self.as_party_join().is_ok()
	}
	/// Tries to convert the enum instance into [`PartyJoinRequest`](crate::model::ChatMessageBody::PartyJoinRequest), extracting the inner [`ChatMessageBodyPartyJoinRequest`](crate::model::ChatMessageBodyPartyJoinRequest).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_join_request(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyPartyJoinRequest, &Self> {
		if let ChatMessageBody::PartyJoinRequest(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyJoinRequest`](crate::model::ChatMessageBody::PartyJoinRequest).
	pub fn is_party_join_request(&self) -> bool {
		self.as_party_join_request().is_ok()
	}
	/// Tries to convert the enum instance into [`PartyLeave`](crate::model::ChatMessageBody::PartyLeave), extracting the inner [`ChatMessageBodyPartyLeave`](crate::model::ChatMessageBodyPartyLeave).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party_leave(
		&self,
	) -> std::result::Result<&crate::model::ChatMessageBodyPartyLeave, &Self> {
		if let ChatMessageBody::PartyLeave(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`PartyLeave`](crate::model::ChatMessageBody::PartyLeave).
	pub fn is_party_leave(&self) -> bool {
		self.as_party_leave().is_ok()
	}
	/// Tries to convert the enum instance into [`Text`](crate::model::ChatMessageBody::Text), extracting the inner [`ChatMessageBodyText`](crate::model::ChatMessageBodyText).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_text(&self) -> std::result::Result<&crate::model::ChatMessageBodyText, &Self> {
		if let ChatMessageBody::Text(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Text`](crate::model::ChatMessageBody::Text).
	pub fn is_text(&self) -> bool {
		self.as_text().is_ok()
	}
	/// Returns true if the enum instance is the `Unknown` variant.
	pub fn is_unknown(&self) -> bool {
		matches!(self, Self::Unknown)
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating a change in the party's current activity.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyPartyActivityChange {
	/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
	pub activity: std::option::Option<crate::model::PartyActivity>,
}
impl ChatMessageBodyPartyActivityChange {
	/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
	pub fn activity(&self) -> std::option::Option<&crate::model::PartyActivity> {
		self.activity.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyPartyActivityChange {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyPartyActivityChange");
		formatter.field("activity", &self.activity);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyPartyActivityChange`](crate::model::ChatMessageBodyPartyActivityChange)
pub mod chat_message_body_party_activity_change {
	/// A builder for [`ChatMessageBodyPartyActivityChange`](crate::model::ChatMessageBodyPartyActivityChange)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) activity: std::option::Option<crate::model::PartyActivity>,
	}
	impl Builder {
		/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
		pub fn activity(mut self, input: crate::model::PartyActivity) -> Self {
			self.activity = Some(input);
			self
		}
		/// A union representing the activity of a given party. - `Idle`: The party is not doing anything. For example, the leader is sitting in the game menu or the players are hanging out on the hub. - `MatchmakerFindingLobby`: There is a find request in progress for the lobby. If the find request fails, it will go back to `Idle`. If the find request succeeds, it will go to `MatchmakerLobby`. - `MatchmakerLobby`: The party is in a lobby. This does not mean that all of the party members are in the lobby, see the member-specific states.
		pub fn set_activity(
			mut self,
			input: std::option::Option<crate::model::PartyActivity>,
		) -> Self {
			self.activity = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyPartyActivityChange`](crate::model::ChatMessageBodyPartyActivityChange)
		pub fn build(self) -> crate::model::ChatMessageBodyPartyActivityChange {
			crate::model::ChatMessageBodyPartyActivityChange {
				activity: self.activity,
			}
		}
	}
}
impl ChatMessageBodyPartyActivityChange {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyPartyActivityChange`](crate::model::ChatMessageBodyPartyActivityChange)
	pub fn builder() -> crate::model::chat_message_body_party_activity_change::Builder {
		crate::model::chat_message_body_party_activity_change::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity left the party.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyPartyLeave {
	/// An identity handle.
	pub identity: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyPartyLeave {
	/// An identity handle.
	pub fn identity(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.identity.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyPartyLeave {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyPartyLeave");
		formatter.field("identity", &self.identity);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyPartyLeave`](crate::model::ChatMessageBodyPartyLeave)
pub mod chat_message_body_party_leave {
	/// A builder for [`ChatMessageBodyPartyLeave`](crate::model::ChatMessageBodyPartyLeave)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn identity(mut self, input: crate::model::IdentityHandle) -> Self {
			self.identity = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_identity(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.identity = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyPartyLeave`](crate::model::ChatMessageBodyPartyLeave)
		pub fn build(self) -> crate::model::ChatMessageBodyPartyLeave {
			crate::model::ChatMessageBodyPartyLeave {
				identity: self.identity,
			}
		}
	}
}
impl ChatMessageBodyPartyLeave {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyPartyLeave`](crate::model::ChatMessageBodyPartyLeave)
	pub fn builder() -> crate::model::chat_message_body_party_leave::Builder {
		crate::model::chat_message_body_party_leave::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity joined the party.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyPartyJoin {
	/// An identity handle.
	pub identity: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyPartyJoin {
	/// An identity handle.
	pub fn identity(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.identity.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyPartyJoin {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyPartyJoin");
		formatter.field("identity", &self.identity);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyPartyJoin`](crate::model::ChatMessageBodyPartyJoin)
pub mod chat_message_body_party_join {
	/// A builder for [`ChatMessageBodyPartyJoin`](crate::model::ChatMessageBodyPartyJoin)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn identity(mut self, input: crate::model::IdentityHandle) -> Self {
			self.identity = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_identity(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.identity = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyPartyJoin`](crate::model::ChatMessageBodyPartyJoin)
		pub fn build(self) -> crate::model::ChatMessageBodyPartyJoin {
			crate::model::ChatMessageBodyPartyJoin {
				identity: self.identity,
			}
		}
	}
}
impl ChatMessageBodyPartyJoin {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyPartyJoin`](crate::model::ChatMessageBodyPartyJoin)
	pub fn builder() -> crate::model::chat_message_body_party_join::Builder {
		crate::model::chat_message_body_party_join::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity requesting to join your party.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyPartyJoinRequest {
	/// An identity handle.
	pub sender: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyPartyJoinRequest {
	/// An identity handle.
	pub fn sender(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.sender.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyPartyJoinRequest {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyPartyJoinRequest");
		formatter.field("sender", &self.sender);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyPartyJoinRequest`](crate::model::ChatMessageBodyPartyJoinRequest)
pub mod chat_message_body_party_join_request {
	/// A builder for [`ChatMessageBodyPartyJoinRequest`](crate::model::ChatMessageBodyPartyJoinRequest)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) sender: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn sender(mut self, input: crate::model::IdentityHandle) -> Self {
			self.sender = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_sender(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.sender = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyPartyJoinRequest`](crate::model::ChatMessageBodyPartyJoinRequest)
		pub fn build(self) -> crate::model::ChatMessageBodyPartyJoinRequest {
			crate::model::ChatMessageBodyPartyJoinRequest {
				sender: self.sender,
			}
		}
	}
}
impl ChatMessageBodyPartyJoinRequest {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyPartyJoinRequest`](crate::model::ChatMessageBodyPartyJoinRequest)
	pub fn builder() -> crate::model::chat_message_body_party_join_request::Builder {
		crate::model::chat_message_body_party_join_request::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant holding an a party invitation.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyPartyInvite {
	/// An identity handle.
	pub sender: std::option::Option<crate::model::IdentityHandle>,
	/// A party handle.
	pub party: std::option::Option<crate::model::PartyHandle>,
	/// Pass to `rivet.api.party#GetPartyFromInvite$token` to view more information about the party. Pass to `rivet.api.party.common#JoinPartyInvite$token` to join the party.
	pub invite_token: std::option::Option<std::string::String>,
}
impl ChatMessageBodyPartyInvite {
	/// An identity handle.
	pub fn sender(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.sender.as_ref()
	}
	/// A party handle.
	pub fn party(&self) -> std::option::Option<&crate::model::PartyHandle> {
		self.party.as_ref()
	}
	/// Pass to `rivet.api.party#GetPartyFromInvite$token` to view more information about the party. Pass to `rivet.api.party.common#JoinPartyInvite$token` to join the party.
	pub fn invite_token(&self) -> std::option::Option<&str> {
		self.invite_token.as_deref()
	}
}
impl std::fmt::Debug for ChatMessageBodyPartyInvite {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyPartyInvite");
		formatter.field("sender", &self.sender);
		formatter.field("party", &self.party);
		formatter.field("invite_token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}
/// See [`ChatMessageBodyPartyInvite`](crate::model::ChatMessageBodyPartyInvite)
pub mod chat_message_body_party_invite {
	/// A builder for [`ChatMessageBodyPartyInvite`](crate::model::ChatMessageBodyPartyInvite)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) sender: std::option::Option<crate::model::IdentityHandle>,
		pub(crate) party: std::option::Option<crate::model::PartyHandle>,
		pub(crate) invite_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// An identity handle.
		pub fn sender(mut self, input: crate::model::IdentityHandle) -> Self {
			self.sender = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_sender(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.sender = input;
			self
		}
		/// A party handle.
		pub fn party(mut self, input: crate::model::PartyHandle) -> Self {
			self.party = Some(input);
			self
		}
		/// A party handle.
		pub fn set_party(mut self, input: std::option::Option<crate::model::PartyHandle>) -> Self {
			self.party = input;
			self
		}
		/// Pass to `rivet.api.party#GetPartyFromInvite$token` to view more information about the party. Pass to `rivet.api.party.common#JoinPartyInvite$token` to join the party.
		pub fn invite_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.invite_token = Some(input.into());
			self
		}
		/// Pass to `rivet.api.party#GetPartyFromInvite$token` to view more information about the party. Pass to `rivet.api.party.common#JoinPartyInvite$token` to join the party.
		pub fn set_invite_token(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.invite_token = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyPartyInvite`](crate::model::ChatMessageBodyPartyInvite)
		pub fn build(self) -> crate::model::ChatMessageBodyPartyInvite {
			crate::model::ChatMessageBodyPartyInvite {
				sender: self.sender,
				party: self.party,
				invite_token: self.invite_token,
			}
		}
	}
}
impl ChatMessageBodyPartyInvite {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyPartyInvite`](crate::model::ChatMessageBodyPartyInvite)
	pub fn builder() -> crate::model::chat_message_body_party_invite::Builder {
		crate::model::chat_message_body_party_invite::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity has been kicked from the group.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyGroupMemberKick {
	/// An identity handle.
	pub identity: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyGroupMemberKick {
	/// An identity handle.
	pub fn identity(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.identity.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyGroupMemberKick {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyGroupMemberKick");
		formatter.field("identity", &self.identity);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyGroupMemberKick`](crate::model::ChatMessageBodyGroupMemberKick)
pub mod chat_message_body_group_member_kick {
	/// A builder for [`ChatMessageBodyGroupMemberKick`](crate::model::ChatMessageBodyGroupMemberKick)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn identity(mut self, input: crate::model::IdentityHandle) -> Self {
			self.identity = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_identity(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.identity = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyGroupMemberKick`](crate::model::ChatMessageBodyGroupMemberKick)
		pub fn build(self) -> crate::model::ChatMessageBodyGroupMemberKick {
			crate::model::ChatMessageBodyGroupMemberKick {
				identity: self.identity,
			}
		}
	}
}
impl ChatMessageBodyGroupMemberKick {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyGroupMemberKick`](crate::model::ChatMessageBodyGroupMemberKick)
	pub fn builder() -> crate::model::chat_message_body_group_member_kick::Builder {
		crate::model::chat_message_body_group_member_kick::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity left the group.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyGroupLeave {
	/// An identity handle.
	pub identity: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyGroupLeave {
	/// An identity handle.
	pub fn identity(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.identity.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyGroupLeave {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyGroupLeave");
		formatter.field("identity", &self.identity);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyGroupLeave`](crate::model::ChatMessageBodyGroupLeave)
pub mod chat_message_body_group_leave {
	/// A builder for [`ChatMessageBodyGroupLeave`](crate::model::ChatMessageBodyGroupLeave)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn identity(mut self, input: crate::model::IdentityHandle) -> Self {
			self.identity = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_identity(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.identity = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyGroupLeave`](crate::model::ChatMessageBodyGroupLeave)
		pub fn build(self) -> crate::model::ChatMessageBodyGroupLeave {
			crate::model::ChatMessageBodyGroupLeave {
				identity: self.identity,
			}
		}
	}
}
impl ChatMessageBodyGroupLeave {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyGroupLeave`](crate::model::ChatMessageBodyGroupLeave)
	pub fn builder() -> crate::model::chat_message_body_group_leave::Builder {
		crate::model::chat_message_body_group_leave::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity joined the group.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyGroupJoin {
	/// An identity handle.
	pub identity: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyGroupJoin {
	/// An identity handle.
	pub fn identity(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.identity.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyGroupJoin {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyGroupJoin");
		formatter.field("identity", &self.identity);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyGroupJoin`](crate::model::ChatMessageBodyGroupJoin)
pub mod chat_message_body_group_join {
	/// A builder for [`ChatMessageBodyGroupJoin`](crate::model::ChatMessageBodyGroupJoin)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn identity(mut self, input: crate::model::IdentityHandle) -> Self {
			self.identity = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_identity(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.identity = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyGroupJoin`](crate::model::ChatMessageBodyGroupJoin)
		pub fn build(self) -> crate::model::ChatMessageBodyGroupJoin {
			crate::model::ChatMessageBodyGroupJoin {
				identity: self.identity,
			}
		}
	}
}
impl ChatMessageBodyGroupJoin {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyGroupJoin`](crate::model::ChatMessageBodyGroupJoin)
	pub fn builder() -> crate::model::chat_message_body_group_join::Builder {
		crate::model::chat_message_body_group_join::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating an identity followed the identity.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyIdentityFollow {}
impl std::fmt::Debug for ChatMessageBodyIdentityFollow {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyIdentityFollow");
		formatter.finish()
	}
}
/// See [`ChatMessageBodyIdentityFollow`](crate::model::ChatMessageBodyIdentityFollow)
pub mod chat_message_body_identity_follow {
	/// A builder for [`ChatMessageBodyIdentityFollow`](crate::model::ChatMessageBodyIdentityFollow)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`ChatMessageBodyIdentityFollow`](crate::model::ChatMessageBodyIdentityFollow)
		pub fn build(self) -> crate::model::ChatMessageBodyIdentityFollow {
			crate::model::ChatMessageBodyIdentityFollow {}
		}
	}
}
impl ChatMessageBodyIdentityFollow {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyIdentityFollow`](crate::model::ChatMessageBodyIdentityFollow)
	pub fn builder() -> crate::model::chat_message_body_identity_follow::Builder {
		crate::model::chat_message_body_identity_follow::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for deleted messages.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyDeleted {
	/// An identity handle.
	pub sender: std::option::Option<crate::model::IdentityHandle>,
}
impl ChatMessageBodyDeleted {
	/// An identity handle.
	pub fn sender(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.sender.as_ref()
	}
}
impl std::fmt::Debug for ChatMessageBodyDeleted {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyDeleted");
		formatter.field("sender", &self.sender);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyDeleted`](crate::model::ChatMessageBodyDeleted)
pub mod chat_message_body_deleted {
	/// A builder for [`ChatMessageBodyDeleted`](crate::model::ChatMessageBodyDeleted)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) sender: std::option::Option<crate::model::IdentityHandle>,
	}
	impl Builder {
		/// An identity handle.
		pub fn sender(mut self, input: crate::model::IdentityHandle) -> Self {
			self.sender = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_sender(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.sender = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyDeleted`](crate::model::ChatMessageBodyDeleted)
		pub fn build(self) -> crate::model::ChatMessageBodyDeleted {
			crate::model::ChatMessageBodyDeleted {
				sender: self.sender,
			}
		}
	}
}
impl ChatMessageBodyDeleted {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyDeleted`](crate::model::ChatMessageBodyDeleted)
	pub fn builder() -> crate::model::chat_message_body_deleted::Builder {
		crate::model::chat_message_body_deleted::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for indicating a new chat was created.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyChatCreate {}
impl std::fmt::Debug for ChatMessageBodyChatCreate {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyChatCreate");
		formatter.finish()
	}
}
/// See [`ChatMessageBodyChatCreate`](crate::model::ChatMessageBodyChatCreate)
pub mod chat_message_body_chat_create {
	/// A builder for [`ChatMessageBodyChatCreate`](crate::model::ChatMessageBodyChatCreate)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`ChatMessageBodyChatCreate`](crate::model::ChatMessageBodyChatCreate)
		pub fn build(self) -> crate::model::ChatMessageBodyChatCreate {
			crate::model::ChatMessageBodyChatCreate {}
		}
	}
}
impl ChatMessageBodyChatCreate {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyChatCreate`](crate::model::ChatMessageBodyChatCreate)
	pub fn builder() -> crate::model::chat_message_body_chat_create::Builder {
		crate::model::chat_message_body_chat_create::Builder::default()
	}
}

/// `rivet.chat#ChatMessageBody` variant for text messages. Sent by other identities using the chat interface.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatMessageBodyText {
	/// An identity handle.
	pub sender: std::option::Option<crate::model::IdentityHandle>,
	/// The text in the message.
	pub body: std::option::Option<std::string::String>,
}
impl ChatMessageBodyText {
	/// An identity handle.
	pub fn sender(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.sender.as_ref()
	}
	/// The text in the message.
	pub fn body(&self) -> std::option::Option<&str> {
		self.body.as_deref()
	}
}
impl std::fmt::Debug for ChatMessageBodyText {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatMessageBodyText");
		formatter.field("sender", &self.sender);
		formatter.field("body", &self.body);
		formatter.finish()
	}
}
/// See [`ChatMessageBodyText`](crate::model::ChatMessageBodyText)
pub mod chat_message_body_text {
	/// A builder for [`ChatMessageBodyText`](crate::model::ChatMessageBodyText)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) sender: std::option::Option<crate::model::IdentityHandle>,
		pub(crate) body: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// An identity handle.
		pub fn sender(mut self, input: crate::model::IdentityHandle) -> Self {
			self.sender = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_sender(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.sender = input;
			self
		}
		/// The text in the message.
		pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
			self.body = Some(input.into());
			self
		}
		/// The text in the message.
		pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.body = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatMessageBodyText`](crate::model::ChatMessageBodyText)
		pub fn build(self) -> crate::model::ChatMessageBodyText {
			crate::model::ChatMessageBodyText {
				sender: self.sender,
				body: self.body,
			}
		}
	}
}
impl ChatMessageBodyText {
	/// Creates a new builder-style object to manufacture [`ChatMessageBodyText`](crate::model::ChatMessageBodyText)
	pub fn builder() -> crate::model::chat_message_body_text::Builder {
		crate::model::chat_message_body_text::Builder::default()
	}
}

/// Represents which direction to query messages from relative to the given
/// timestamp.
#[non_exhaustive]
#[derive(
	std::clone::Clone,
	std::cmp::Eq,
	std::cmp::Ord,
	std::cmp::PartialEq,
	std::cmp::PartialOrd,
	std::fmt::Debug,
	std::hash::Hash,
)]
pub enum QueryDirection {
	/// Query messages after given timestamp.
	After,
	/// Query messages send before given timestamp.
	Before,
	/// Query messages before and after the given timestamp. This will return at most `count * 2` messages.
	BeforeAndAfter,
	/// Unknown contains new variants that have been added since this code was generated.
	Unknown(String),
}
impl std::convert::From<&str> for QueryDirection {
	fn from(s: &str) -> Self {
		match s {
			"after" => QueryDirection::After,
			"before" => QueryDirection::Before,
			"before_and_after" => QueryDirection::BeforeAndAfter,
			other => QueryDirection::Unknown(other.to_owned()),
		}
	}
}
impl std::str::FromStr for QueryDirection {
	type Err = std::convert::Infallible;

	fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
		Ok(QueryDirection::from(s))
	}
}
impl QueryDirection {
	/// Returns the `&str` value of the enum member.
	pub fn as_str(&self) -> &str {
		match self {
			QueryDirection::After => "after",
			QueryDirection::Before => "before",
			QueryDirection::BeforeAndAfter => "before_and_after",
			QueryDirection::Unknown(s) => s.as_ref(),
		}
	}
	/// Returns all the `&str` values of the enum members.
	pub fn values() -> &'static [&'static str] {
		&["after", "before", "before_and_after"]
	}
}
impl AsRef<str> for QueryDirection {
	fn as_ref(&self) -> &str {
		self.as_str()
	}
}

/// Provided by watchable endpoints used in blocking loops.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WatchResponse {
	/// Index indicating the version of the data responded. Pas this to `rivet.common#WatchQuery` to block and wait for the next response.
	pub index: std::option::Option<std::string::String>,
}
impl WatchResponse {
	/// Index indicating the version of the data responded. Pas this to `rivet.common#WatchQuery` to block and wait for the next response.
	pub fn index(&self) -> std::option::Option<&str> {
		self.index.as_deref()
	}
}
impl std::fmt::Debug for WatchResponse {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("WatchResponse");
		formatter.field("index", &self.index);
		formatter.finish()
	}
}
/// See [`WatchResponse`](crate::model::WatchResponse)
pub mod watch_response {
	/// A builder for [`WatchResponse`](crate::model::WatchResponse)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Index indicating the version of the data responded. Pas this to `rivet.common#WatchQuery` to block and wait for the next response.
		pub fn index(mut self, input: impl Into<std::string::String>) -> Self {
			self.index = Some(input.into());
			self
		}
		/// Index indicating the version of the data responded. Pas this to `rivet.common#WatchQuery` to block and wait for the next response.
		pub fn set_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.index = input;
			self
		}
		/// Consumes the builder and constructs a [`WatchResponse`](crate::model::WatchResponse)
		pub fn build(self) -> crate::model::WatchResponse {
			crate::model::WatchResponse { index: self.index }
		}
	}
}
impl WatchResponse {
	/// Creates a new builder-style object to manufacture [`WatchResponse`](crate::model::WatchResponse)
	pub fn builder() -> crate::model::watch_response::Builder {
		crate::model::watch_response::Builder::default()
	}
}

/// The chat typing status of an identity.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatIdentityTypingStatus {
	/// An identity handle.
	pub identity: std::option::Option<crate::model::IdentityHandle>,
	/// Represents a chat typing status.
	pub status: std::option::Option<crate::model::ChatTypingStatus>,
}
impl ChatIdentityTypingStatus {
	/// An identity handle.
	pub fn identity(&self) -> std::option::Option<&crate::model::IdentityHandle> {
		self.identity.as_ref()
	}
	/// Represents a chat typing status.
	pub fn status(&self) -> std::option::Option<&crate::model::ChatTypingStatus> {
		self.status.as_ref()
	}
}
impl std::fmt::Debug for ChatIdentityTypingStatus {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatIdentityTypingStatus");
		formatter.field("identity", &self.identity);
		formatter.field("status", &self.status);
		formatter.finish()
	}
}
/// See [`ChatIdentityTypingStatus`](crate::model::ChatIdentityTypingStatus)
pub mod chat_identity_typing_status {
	/// A builder for [`ChatIdentityTypingStatus`](crate::model::ChatIdentityTypingStatus)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity: std::option::Option<crate::model::IdentityHandle>,
		pub(crate) status: std::option::Option<crate::model::ChatTypingStatus>,
	}
	impl Builder {
		/// An identity handle.
		pub fn identity(mut self, input: crate::model::IdentityHandle) -> Self {
			self.identity = Some(input);
			self
		}
		/// An identity handle.
		pub fn set_identity(
			mut self,
			input: std::option::Option<crate::model::IdentityHandle>,
		) -> Self {
			self.identity = input;
			self
		}
		/// Represents a chat typing status.
		pub fn status(mut self, input: crate::model::ChatTypingStatus) -> Self {
			self.status = Some(input);
			self
		}
		/// Represents a chat typing status.
		pub fn set_status(
			mut self,
			input: std::option::Option<crate::model::ChatTypingStatus>,
		) -> Self {
			self.status = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatIdentityTypingStatus`](crate::model::ChatIdentityTypingStatus)
		pub fn build(self) -> crate::model::ChatIdentityTypingStatus {
			crate::model::ChatIdentityTypingStatus {
				identity: self.identity,
				status: self.status,
			}
		}
	}
}
impl ChatIdentityTypingStatus {
	/// Creates a new builder-style object to manufacture [`ChatIdentityTypingStatus`](crate::model::ChatIdentityTypingStatus)
	pub fn builder() -> crate::model::chat_identity_typing_status::Builder {
		crate::model::chat_identity_typing_status::Builder::default()
	}
}

/// Represents a topic of the given chat thread without the associated handles for the topic.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ChatSimpleTopic {
	/// `rivet.chat#ChatSimpleTopic` variant for direct (identity to identity) chats.
	Direct(crate::model::ChatSimpleTopicDirect),
	/// `rivet.chat#ChatSimpleTopic` variant for groups.
	Group(crate::model::ChatSimpleTopicGroup),
	/// `rivet.chat#ChatSimpleTopic` variant for parties.
	Party(crate::model::ChatSimpleTopicParty),
	/// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
	/// An unknown enum variant
	///
	/// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
	/// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
	/// by the client. This can happen when the server adds new functionality, but the client has not been updated.
	/// To investigate this, consider turning on debug logging to print the raw HTTP response.
	#[non_exhaustive]
	Unknown,
}
impl ChatSimpleTopic {
	/// Tries to convert the enum instance into [`Direct`](crate::model::ChatSimpleTopic::Direct), extracting the inner [`ChatSimpleTopicDirect`](crate::model::ChatSimpleTopicDirect).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_direct(&self) -> std::result::Result<&crate::model::ChatSimpleTopicDirect, &Self> {
		if let ChatSimpleTopic::Direct(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Direct`](crate::model::ChatSimpleTopic::Direct).
	pub fn is_direct(&self) -> bool {
		self.as_direct().is_ok()
	}
	/// Tries to convert the enum instance into [`Group`](crate::model::ChatSimpleTopic::Group), extracting the inner [`ChatSimpleTopicGroup`](crate::model::ChatSimpleTopicGroup).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_group(&self) -> std::result::Result<&crate::model::ChatSimpleTopicGroup, &Self> {
		if let ChatSimpleTopic::Group(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Group`](crate::model::ChatSimpleTopic::Group).
	pub fn is_group(&self) -> bool {
		self.as_group().is_ok()
	}
	/// Tries to convert the enum instance into [`Party`](crate::model::ChatSimpleTopic::Party), extracting the inner [`ChatSimpleTopicParty`](crate::model::ChatSimpleTopicParty).
	/// Returns `Err(&Self)` if it can't be converted.
	pub fn as_party(&self) -> std::result::Result<&crate::model::ChatSimpleTopicParty, &Self> {
		if let ChatSimpleTopic::Party(val) = &self {
			Ok(val)
		} else {
			Err(self)
		}
	}
	/// Returns true if this is a [`Party`](crate::model::ChatSimpleTopic::Party).
	pub fn is_party(&self) -> bool {
		self.as_party().is_ok()
	}
	/// Returns true if the enum instance is the `Unknown` variant.
	pub fn is_unknown(&self) -> bool {
		matches!(self, Self::Unknown)
	}
}

/// `rivet.chat#ChatSimpleTopic` variant for direct (identity to identity) chats.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatSimpleTopicDirect {
	/// A universally unique identifier.
	pub identity_a_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub identity_b_id: std::option::Option<std::string::String>,
}
impl ChatSimpleTopicDirect {
	/// A universally unique identifier.
	pub fn identity_a_id(&self) -> std::option::Option<&str> {
		self.identity_a_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn identity_b_id(&self) -> std::option::Option<&str> {
		self.identity_b_id.as_deref()
	}
}
impl std::fmt::Debug for ChatSimpleTopicDirect {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatSimpleTopicDirect");
		formatter.field("identity_a_id", &self.identity_a_id);
		formatter.field("identity_b_id", &self.identity_b_id);
		formatter.finish()
	}
}
/// See [`ChatSimpleTopicDirect`](crate::model::ChatSimpleTopicDirect)
pub mod chat_simple_topic_direct {
	/// A builder for [`ChatSimpleTopicDirect`](crate::model::ChatSimpleTopicDirect)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_a_id: std::option::Option<std::string::String>,
		pub(crate) identity_b_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_a_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_a_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_a_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.identity_a_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn identity_b_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_b_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_b_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.identity_b_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatSimpleTopicDirect`](crate::model::ChatSimpleTopicDirect)
		pub fn build(self) -> crate::model::ChatSimpleTopicDirect {
			crate::model::ChatSimpleTopicDirect {
				identity_a_id: self.identity_a_id,
				identity_b_id: self.identity_b_id,
			}
		}
	}
}
impl ChatSimpleTopicDirect {
	/// Creates a new builder-style object to manufacture [`ChatSimpleTopicDirect`](crate::model::ChatSimpleTopicDirect)
	pub fn builder() -> crate::model::chat_simple_topic_direct::Builder {
		crate::model::chat_simple_topic_direct::Builder::default()
	}
}

/// `rivet.chat#ChatSimpleTopic` variant for parties.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatSimpleTopicParty {
	/// A universally unique identifier.
	pub party_id: std::option::Option<std::string::String>,
}
impl ChatSimpleTopicParty {
	/// A universally unique identifier.
	pub fn party_id(&self) -> std::option::Option<&str> {
		self.party_id.as_deref()
	}
}
impl std::fmt::Debug for ChatSimpleTopicParty {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatSimpleTopicParty");
		formatter.field("party_id", &self.party_id);
		formatter.finish()
	}
}
/// See [`ChatSimpleTopicParty`](crate::model::ChatSimpleTopicParty)
pub mod chat_simple_topic_party {
	/// A builder for [`ChatSimpleTopicParty`](crate::model::ChatSimpleTopicParty)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) party_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn party_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.party_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_party_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.party_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatSimpleTopicParty`](crate::model::ChatSimpleTopicParty)
		pub fn build(self) -> crate::model::ChatSimpleTopicParty {
			crate::model::ChatSimpleTopicParty {
				party_id: self.party_id,
			}
		}
	}
}
impl ChatSimpleTopicParty {
	/// Creates a new builder-style object to manufacture [`ChatSimpleTopicParty`](crate::model::ChatSimpleTopicParty)
	pub fn builder() -> crate::model::chat_simple_topic_party::Builder {
		crate::model::chat_simple_topic_party::Builder::default()
	}
}

/// `rivet.chat#ChatSimpleTopic` variant for groups.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChatSimpleTopicGroup {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl ChatSimpleTopicGroup {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for ChatSimpleTopicGroup {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ChatSimpleTopicGroup");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}
/// See [`ChatSimpleTopicGroup`](crate::model::ChatSimpleTopicGroup)
pub mod chat_simple_topic_group {
	/// A builder for [`ChatSimpleTopicGroup`](crate::model::ChatSimpleTopicGroup)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ChatSimpleTopicGroup`](crate::model::ChatSimpleTopicGroup)
		pub fn build(self) -> crate::model::ChatSimpleTopicGroup {
			crate::model::ChatSimpleTopicGroup {
				group_id: self.group_id,
			}
		}
	}
}
impl ChatSimpleTopicGroup {
	/// Creates a new builder-style object to manufacture [`ChatSimpleTopicGroup`](crate::model::ChatSimpleTopicGroup)
	pub fn builder() -> crate::model::chat_simple_topic_group::Builder {
		crate::model::chat_simple_topic_group::Builder::default()
	}
}
