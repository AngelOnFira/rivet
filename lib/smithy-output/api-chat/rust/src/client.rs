// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<C, M, R = aws_smithy_client::retry::Standard> {
	pub(crate) client: aws_smithy_client::Client<C, M, R>,
	pub(crate) conf: crate::Config,
}

/// An ergonomic service client for `ChatService`.
///
/// This client allows ergonomic access to a `ChatService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Constructing a Client
///
/// To construct a client, you need a few different things:
///
/// - A [`Config`](crate::Config) that specifies additional configuration
///   required by the service.
/// - A connector (`C`) that specifies how HTTP requests are translated
///   into HTTP responses. This will typically be an HTTP client (like
///   `hyper`), though you can also substitute in your own, like a mock
///   mock connector for testing.
/// - A "middleware" (`M`) that modifies requests prior to them being
///   sent to the request. Most commonly, middleware will decide what
///   endpoint the requests should be sent to, as well as perform
///   authentication and authorization of requests (such as SigV4).
///   You can also have middleware that performs request/response
///   tracing, throttling, or other middleware-like tasks.
/// - A retry policy (`R`) that dictates the behavior for requests that
///   fail and should (potentially) be retried. The default type is
///   generally what you want, as it implements a well-vetted retry
///   policy implemented in [`RetryMode::Standard`](aws_smithy_types::retry::RetryMode::Standard).
///
/// To construct a client, you will generally want to call
/// [`Client::with_config`], which takes a [`aws_smithy_client::Client`] (a
/// Smithy client that isn't specialized to a particular service),
/// and a [`Config`](crate::Config). Both of these are constructed using
/// the [builder pattern] where you first construct a `Builder` type,
/// then configure it with the necessary parameters, and then call
/// `build` to construct the finalized output type. The
/// [`aws_smithy_client::Client`] builder is re-exported in this crate as
/// [`Builder`] for convenience.
///
/// In _most_ circumstances, you will want to use the following pattern
/// to construct a client:
///
/// ```
/// use rivet_chat::{Builder, Client, Config};
/// let raw_client =
///     Builder::dyn_https()
/// #     /*
///       .middleware(/* discussed below */)
/// #     */
/// #     .middleware_fn(|r| r)
///       .build();
/// let config = Config::builder().build();
/// let client = Client::with_config(raw_client, config);
/// ```
///
/// For the middleware, you'll want to use whatever matches the
/// routing, authentication and authorization required by the target
/// service. For example, for the standard AWS SDK which uses
/// [SigV4-signed requests], the middleware looks like this:
///
// Ignored as otherwise we'd need to pull in all these dev-dependencies.
/// ```rust,ignore
/// use aws_endpoint::AwsEndpointStage;
/// use aws_http::auth::CredentialsStage;
/// use aws_http::recursion_detection::RecursionDetectionStage;
/// use aws_http::user_agent::UserAgentStage;
/// use aws_sig_auth::middleware::SigV4SigningStage;
/// use aws_sig_auth::signer::SigV4Signer;
/// use aws_smithy_client::retry::Config as RetryConfig;
/// use aws_smithy_http_tower::map_request::{AsyncMapRequestLayer, MapRequestLayer};
/// use std::fmt::Debug;
/// use tower::layer::util::{Identity, Stack};
/// use tower::ServiceBuilder;
///
/// type AwsMiddlewareStack = Stack<
///     MapRequestLayer<RecursionDetectionStage>,
///     Stack<
///         MapRequestLayer<SigV4SigningStage>,
///         Stack<
///             AsyncMapRequestLayer<CredentialsStage>,
///             Stack<
///                 MapRequestLayer<UserAgentStage>,
///                 Stack<MapRequestLayer<AwsEndpointStage>, Identity>,
///             >,
///         >,
///     >,
/// >;
///
/// /// AWS Middleware Stack
/// ///
/// /// This implements the middleware stack for this service. It will:
/// /// 1. Load credentials asynchronously into the property bag
/// /// 2. Sign the request with SigV4
/// /// 3. Resolve an Endpoint for the request
/// /// 4. Add a user agent to the request
/// #[derive(Debug, Default, Clone)]
/// #[non_exhaustive]
/// pub struct AwsMiddleware;
///
/// impl AwsMiddleware {
///     /// Create a new `AwsMiddleware` stack
///     ///
///     /// Note: `AwsMiddleware` holds no state.
///     pub fn new() -> Self {
///         AwsMiddleware::default()
///     }
/// }
///
/// // define the middleware stack in a non-generic location to reduce code bloat.
/// fn base() -> ServiceBuilder<AwsMiddlewareStack> {
///     let credential_provider = AsyncMapRequestLayer::for_mapper(CredentialsStage::new());
///     let signer = MapRequestLayer::for_mapper(SigV4SigningStage::new(SigV4Signer::new()));
///     let endpoint_resolver = MapRequestLayer::for_mapper(AwsEndpointStage);
///     let user_agent = MapRequestLayer::for_mapper(UserAgentStage::new());
///     let recursion_detection = MapRequestLayer::for_mapper(RecursionDetectionStage::new());
///     // These layers can be considered as occurring in order, that is:
///     // 1. Resolve an endpoint
///     // 2. Add a user agent
///     // 3. Acquire credentials
///     // 4. Sign with credentials
///     // (5. Dispatch over the wire)
///     ServiceBuilder::new()
///         .layer(endpoint_resolver)
///         .layer(user_agent)
///         .layer(credential_provider)
///         .layer(signer)
///         .layer(recursion_detection)
/// }
///
/// impl<S> tower::Layer<S> for AwsMiddleware {
///     type Service = <AwsMiddlewareStack as tower::Layer<S>>::Service;
///
///     fn layer(&self, inner: S) -> Self::Service {
///         base().service(inner)
///     }
/// }
/// ```
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<C, M, R = aws_smithy_client::retry::Standard> {
	handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
	fn clone(&self) -> Self {
		Self {
			handle: self.handle.clone(),
		}
	}
}

#[doc(inline)]
pub use aws_smithy_client::Builder;

impl<C, M, R> From<aws_smithy_client::Client<C, M, R>> for Client<C, M, R> {
	fn from(client: aws_smithy_client::Client<C, M, R>) -> Self {
		Self::with_config(client, crate::Config::builder().build())
	}
}

impl<C, M, R> Client<C, M, R> {
	/// Creates a client with the given service configuration.
	pub fn with_config(client: aws_smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
		Self {
			handle: std::sync::Arc::new(Handle { client, conf }),
		}
	}

	/// Returns the client's configuration.
	pub fn conf(&self) -> &crate::Config {
		&self.handle.conf
	}
}
impl<C, M, R> Client<C, M, R>
where
	C: aws_smithy_client::bounds::SmithyConnector,
	M: aws_smithy_client::bounds::SmithyMiddleware<C>,
	R: aws_smithy_client::retry::NewRequestPolicy,
{
	/// Constructs a fluent builder for the [`GetDirectThread`](crate::client::fluent_builders::GetDirectThread) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`identity_id(impl Into<String>)`](crate::client::fluent_builders::GetDirectThread::identity_id) / [`set_identity_id(Option<String>)`](crate::client::fluent_builders::GetDirectThread::set_identity_id): A universally unique identifier.
	/// - On success, responds with [`GetDirectThreadOutput`](crate::output::GetDirectThreadOutput) with field(s):
	///   - [`thread_id(Option<String>)`](crate::output::GetDirectThreadOutput::thread_id): A universally unique identifier.
	///   - [`identity(Option<IdentityHandle>)`](crate::output::GetDirectThreadOutput::identity): An identity handle.
	/// - On failure, responds with [`SdkError<GetDirectThreadError>`](crate::error::GetDirectThreadError)
	pub fn get_direct_thread(&self) -> fluent_builders::GetDirectThread<C, M, R> {
		fluent_builders::GetDirectThread::new(self.handle.clone())
	}
	/// Constructs a fluent builder for the [`GetThreadHistory`](crate::client::fluent_builders::GetThreadHistory) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`thread_id(impl Into<String>)`](crate::client::fluent_builders::GetThreadHistory::thread_id) / [`set_thread_id(Option<String>)`](crate::client::fluent_builders::GetThreadHistory::set_thread_id): A universally unique identifier.
	///   - [`ts(DateTime)`](crate::client::fluent_builders::GetThreadHistory::ts) / [`set_ts(Option<DateTime>)`](crate::client::fluent_builders::GetThreadHistory::set_ts): RFC3339 timestamp.
	///   - [`count(i32)`](crate::client::fluent_builders::GetThreadHistory::count) / [`set_count(Option<i32>)`](crate::client::fluent_builders::GetThreadHistory::set_count): How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
	///   - [`query_direction(QueryDirection)`](crate::client::fluent_builders::GetThreadHistory::query_direction) / [`set_query_direction(Option<QueryDirection>)`](crate::client::fluent_builders::GetThreadHistory::set_query_direction): Represents which direction to query messages from relative to the given timestamp.
	/// - On success, responds with [`GetThreadHistoryOutput`](crate::output::GetThreadHistoryOutput) with field(s):
	///   - [`chat_messages(Option<Vec<ChatMessage>>)`](crate::output::GetThreadHistoryOutput::chat_messages): Ordered old to new. If querying `rivet.api.chat.common#before_and_after`, this will be `count * 2` long.
	/// - On failure, responds with [`SdkError<GetThreadHistoryError>`](crate::error::GetThreadHistoryError)
	pub fn get_thread_history(&self) -> fluent_builders::GetThreadHistory<C, M, R> {
		fluent_builders::GetThreadHistory::new(self.handle.clone())
	}
	/// Constructs a fluent builder for the [`GetThreadTopic`](crate::client::fluent_builders::GetThreadTopic) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`thread_id(impl Into<String>)`](crate::client::fluent_builders::GetThreadTopic::thread_id) / [`set_thread_id(Option<String>)`](crate::client::fluent_builders::GetThreadTopic::set_thread_id): A universally unique identifier.
	/// - On success, responds with [`GetThreadTopicOutput`](crate::output::GetThreadTopicOutput) with field(s):
	///   - [`topic(Option<ChatSimpleTopic>)`](crate::output::GetThreadTopicOutput::topic): Represents a topic of the given chat thread without the associated handles for the topic.
	/// - On failure, responds with [`SdkError<GetThreadTopicError>`](crate::error::GetThreadTopicError)
	pub fn get_thread_topic(&self) -> fluent_builders::GetThreadTopic<C, M, R> {
		fluent_builders::GetThreadTopic::new(self.handle.clone())
	}
	/// Constructs a fluent builder for the [`SendChatMessage`](crate::client::fluent_builders::SendChatMessage) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`topic(SendChatTopic)`](crate::client::fluent_builders::SendChatMessage::topic) / [`set_topic(Option<SendChatTopic>)`](crate::client::fluent_builders::SendChatMessage::set_topic): Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
	///   - [`message_body(SendMessageBody)`](crate::client::fluent_builders::SendChatMessage::message_body) / [`set_message_body(Option<SendMessageBody>)`](crate::client::fluent_builders::SendChatMessage::set_message_body): Data to send in a chat message.
	/// - On success, responds with [`SendChatMessageOutput`](crate::output::SendChatMessageOutput) with field(s):
	///   - [`chat_message_id(Option<String>)`](crate::output::SendChatMessageOutput::chat_message_id): A universally unique identifier.
	/// - On failure, responds with [`SdkError<SendChatMessageError>`](crate::error::SendChatMessageError)
	pub fn send_chat_message(&self) -> fluent_builders::SendChatMessage<C, M, R> {
		fluent_builders::SendChatMessage::new(self.handle.clone())
	}
	/// Constructs a fluent builder for the [`SetThreadRead`](crate::client::fluent_builders::SetThreadRead) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`thread_id(impl Into<String>)`](crate::client::fluent_builders::SetThreadRead::thread_id) / [`set_thread_id(Option<String>)`](crate::client::fluent_builders::SetThreadRead::set_thread_id): A universally unique identifier.
	///   - [`last_read_ts(DateTime)`](crate::client::fluent_builders::SetThreadRead::last_read_ts) / [`set_last_read_ts(Option<DateTime>)`](crate::client::fluent_builders::SetThreadRead::set_last_read_ts): Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
	/// - On success, responds with [`SetThreadReadOutput`](crate::output::SetThreadReadOutput)

	/// - On failure, responds with [`SdkError<SetThreadReadError>`](crate::error::SetThreadReadError)
	pub fn set_thread_read(&self) -> fluent_builders::SetThreadRead<C, M, R> {
		fluent_builders::SetThreadRead::new(self.handle.clone())
	}
	/// Constructs a fluent builder for the [`SetTypingStatus`](crate::client::fluent_builders::SetTypingStatus) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`thread_id(impl Into<String>)`](crate::client::fluent_builders::SetTypingStatus::thread_id) / [`set_thread_id(Option<String>)`](crate::client::fluent_builders::SetTypingStatus::set_thread_id): A universally unique identifier.
	///   - [`status(ChatTypingStatus)`](crate::client::fluent_builders::SetTypingStatus::status) / [`set_status(Option<ChatTypingStatus>)`](crate::client::fluent_builders::SetTypingStatus::set_status): Represents a chat typing status.
	/// - On success, responds with [`SetTypingStatusOutput`](crate::output::SetTypingStatusOutput)

	/// - On failure, responds with [`SdkError<SetTypingStatusError>`](crate::error::SetTypingStatusError)
	pub fn set_typing_status(&self) -> fluent_builders::SetTypingStatus<C, M, R> {
		fluent_builders::SetTypingStatus::new(self.handle.clone())
	}
	/// Constructs a fluent builder for the [`WatchThread`](crate::client::fluent_builders::WatchThread) operation.
	///
	/// - The fluent builder is configurable:
	///   - [`thread_id(impl Into<String>)`](crate::client::fluent_builders::WatchThread::thread_id) / [`set_thread_id(Option<String>)`](crate::client::fluent_builders::WatchThread::set_thread_id): A universally unique identifier.
	///   - [`watch_index(impl Into<String>)`](crate::client::fluent_builders::WatchThread::watch_index) / [`set_watch_index(Option<String>)`](crate::client::fluent_builders::WatchThread::set_watch_index): A query parameter denoting the requests watch index.
	/// - On success, responds with [`WatchThreadOutput`](crate::output::WatchThreadOutput) with field(s):
	///   - [`chat_messages(Option<Vec<ChatMessage>>)`](crate::output::WatchThreadOutput::chat_messages): All messages new messages posted to this thread. Ordered old to new.
	///   - [`typing_statuses(Option<Vec<ChatIdentityTypingStatus>>)`](crate::output::WatchThreadOutput::typing_statuses): All identities that are currently typing in this thread.
	///   - [`watch(Option<WatchResponse>)`](crate::output::WatchThreadOutput::watch): Provided by watchable endpoints used in blocking loops.
	/// - On failure, responds with [`SdkError<WatchThreadError>`](crate::error::WatchThreadError)
	pub fn watch_thread(&self) -> fluent_builders::WatchThread<C, M, R> {
		fluent_builders::WatchThread::new(self.handle.clone())
	}
}
pub mod fluent_builders {
	//!
	//! Utilities to ergonomically construct a request to the service.
	//!
	//! Fluent builders are created through the [`Client`](crate::client::Client) by calling
	//! one if its operation methods. After parameters are set using the builder methods,
	//! the `send` method can be called to initiate the request.
	//!
	/// Fluent builder constructing a request to `GetDirectThread`.
	///
	/// Returns a thread ID with a given identity.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct GetDirectThread<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::get_direct_thread_input::Builder,
	}
	impl<C, M, R> GetDirectThread<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `GetDirectThread`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::GetDirectThreadOutput,
			aws_smithy_http::result::SdkError<crate::error::GetDirectThreadError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::GetDirectThreadInputOperationOutputAlias,
				crate::output::GetDirectThreadOutput,
				crate::error::GetDirectThreadError,
				crate::input::GetDirectThreadInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.identity_id(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_identity_id(input);
			self
		}
	}
	/// Fluent builder constructing a request to `GetThreadHistory`.
	///
	/// Returns message history for a given thread in a certain direction. Defaults to querying messages before ts.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct GetThreadHistory<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::get_thread_history_input::Builder,
	}
	impl<C, M, R> GetThreadHistory<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `GetThreadHistory`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::GetThreadHistoryOutput,
			aws_smithy_http::result::SdkError<crate::error::GetThreadHistoryError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::GetThreadHistoryInputOperationOutputAlias,
				crate::output::GetThreadHistoryOutput,
				crate::error::GetThreadHistoryError,
				crate::input::GetThreadHistoryInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.thread_id(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_thread_id(input);
			self
		}
		/// RFC3339 timestamp.
		pub fn ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.inner = self.inner.ts(input);
			self
		}
		/// RFC3339 timestamp.
		pub fn set_ts(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
			self.inner = self.inner.set_ts(input);
			self
		}
		/// How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
		pub fn count(mut self, input: i32) -> Self {
			self.inner = self.inner.count(input);
			self
		}
		/// How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.inner = self.inner.set_count(input);
			self
		}
		/// Represents which direction to query messages from relative to the given timestamp.
		pub fn query_direction(mut self, input: crate::model::QueryDirection) -> Self {
			self.inner = self.inner.query_direction(input);
			self
		}
		/// Represents which direction to query messages from relative to the given timestamp.
		pub fn set_query_direction(
			mut self,
			input: std::option::Option<crate::model::QueryDirection>,
		) -> Self {
			self.inner = self.inner.set_query_direction(input);
			self
		}
	}
	/// Fluent builder constructing a request to `GetThreadTopic`.
	///
	/// Fetches the topic of a thread.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct GetThreadTopic<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::get_thread_topic_input::Builder,
	}
	impl<C, M, R> GetThreadTopic<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `GetThreadTopic`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::GetThreadTopicOutput,
			aws_smithy_http::result::SdkError<crate::error::GetThreadTopicError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::GetThreadTopicInputOperationOutputAlias,
				crate::output::GetThreadTopicOutput,
				crate::error::GetThreadTopicError,
				crate::input::GetThreadTopicInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.thread_id(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_thread_id(input);
			self
		}
	}
	/// Fluent builder constructing a request to `SendChatMessage`.
	///
	/// Sends a chat message to a given topic.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct SendChatMessage<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::send_chat_message_input::Builder,
	}
	impl<C, M, R> SendChatMessage<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `SendChatMessage`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::SendChatMessageOutput,
			aws_smithy_http::result::SdkError<crate::error::SendChatMessageError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::SendChatMessageInputOperationOutputAlias,
				crate::output::SendChatMessageOutput,
				crate::error::SendChatMessageError,
				crate::input::SendChatMessageInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
		pub fn topic(mut self, input: crate::model::SendChatTopic) -> Self {
			self.inner = self.inner.topic(input);
			self
		}
		/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
		pub fn set_topic(
			mut self,
			input: std::option::Option<crate::model::SendChatTopic>,
		) -> Self {
			self.inner = self.inner.set_topic(input);
			self
		}
		/// Data to send in a chat message.
		pub fn message_body(mut self, input: crate::model::SendMessageBody) -> Self {
			self.inner = self.inner.message_body(input);
			self
		}
		/// Data to send in a chat message.
		pub fn set_message_body(
			mut self,
			input: std::option::Option<crate::model::SendMessageBody>,
		) -> Self {
			self.inner = self.inner.set_message_body(input);
			self
		}
	}
	/// Fluent builder constructing a request to `SetThreadRead`.
	///
	/// Updates the current identity's last read timestamp in the given thread.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct SetThreadRead<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::set_thread_read_input::Builder,
	}
	impl<C, M, R> SetThreadRead<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `SetThreadRead`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::SetThreadReadOutput,
			aws_smithy_http::result::SdkError<crate::error::SetThreadReadError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::SetThreadReadInputOperationOutputAlias,
				crate::output::SetThreadReadOutput,
				crate::error::SetThreadReadError,
				crate::input::SetThreadReadInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.thread_id(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_thread_id(input);
			self
		}
		/// Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
		pub fn last_read_ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.inner = self.inner.last_read_ts(input);
			self
		}
		/// Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
		pub fn set_last_read_ts(
			mut self,
			input: std::option::Option<aws_smithy_types::DateTime>,
		) -> Self {
			self.inner = self.inner.set_last_read_ts(input);
			self
		}
	}
	/// Fluent builder constructing a request to `SetTypingStatus`.
	///
	/// Updates the current identity's typing status in the given thread.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct SetTypingStatus<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::set_typing_status_input::Builder,
	}
	impl<C, M, R> SetTypingStatus<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `SetTypingStatus`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::SetTypingStatusOutput,
			aws_smithy_http::result::SdkError<crate::error::SetTypingStatusError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::SetTypingStatusInputOperationOutputAlias,
				crate::output::SetTypingStatusOutput,
				crate::error::SetTypingStatusError,
				crate::input::SetTypingStatusInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.thread_id(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_thread_id(input);
			self
		}
		/// Represents a chat typing status.
		pub fn status(mut self, input: crate::model::ChatTypingStatus) -> Self {
			self.inner = self.inner.status(input);
			self
		}
		/// Represents a chat typing status.
		pub fn set_status(
			mut self,
			input: std::option::Option<crate::model::ChatTypingStatus>,
		) -> Self {
			self.inner = self.inner.set_status(input);
			self
		}
	}
	/// Fluent builder constructing a request to `WatchThread`.
	///
	/// Fetches all relevant changes from a thread that have happened since the given watch index.
	#[derive(std::clone::Clone, std::fmt::Debug)]
	pub struct WatchThread<C, M, R = aws_smithy_client::retry::Standard> {
		handle: std::sync::Arc<super::Handle<C, M, R>>,
		inner: crate::input::watch_thread_input::Builder,
	}
	impl<C, M, R> WatchThread<C, M, R>
	where
		C: aws_smithy_client::bounds::SmithyConnector,
		M: aws_smithy_client::bounds::SmithyMiddleware<C>,
		R: aws_smithy_client::retry::NewRequestPolicy,
	{
		/// Creates a new `WatchThread`.
		pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
			Self {
				handle,
				inner: Default::default(),
			}
		}

		/// Sends the request and returns the response.
		///
		/// If an error occurs, an `SdkError` will be returned with additional details that
		/// can be matched against.
		///
		/// By default, any retryable failures will be retried twice. Retry behavior
		/// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
		/// set when configuring the client.
		pub async fn send(
			self,
		) -> std::result::Result<
			crate::output::WatchThreadOutput,
			aws_smithy_http::result::SdkError<crate::error::WatchThreadError>,
		>
		where
			R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
				crate::input::WatchThreadInputOperationOutputAlias,
				crate::output::WatchThreadOutput,
				crate::error::WatchThreadError,
				crate::input::WatchThreadInputOperationRetryAlias,
			>,
		{
			let op = self
				.inner
				.build()
				.map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?
				.make_operation(&self.handle.conf)
				.await
				.map_err(|err| {
					aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
				})?;
			self.handle.client.call(op).await
		}
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.thread_id(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_thread_id(input);
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.inner = self.inner.watch_index(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.inner = self.inner.set_watch_index(input);
			self
		}
	}
}
/// A wrapper around [`Client`]. Helps reduce external imports.
pub struct ClientWrapper {
	pub(crate) client: Client<aws_smithy_client::erase::DynConnector, tower::layer::util::Identity>,
}

impl std::ops::Deref for ClientWrapper {
	type Target = Client<aws_smithy_client::erase::DynConnector, tower::layer::util::Identity>;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}
