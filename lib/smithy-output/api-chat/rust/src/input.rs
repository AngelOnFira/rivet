// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`GetDirectThreadInput`](crate::input::GetDirectThreadInput)
pub mod get_direct_thread_input {
	/// A builder for [`GetDirectThreadInput`](crate::input::GetDirectThreadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetDirectThreadInput`](crate::input::GetDirectThreadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetDirectThreadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetDirectThreadInput {
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetDirectThreadInputOperationOutputAlias = crate::operation::GetDirectThread;
#[doc(hidden)]
pub type GetDirectThreadInputOperationRetryAlias = ();
impl GetDirectThreadInput {
	/// Consumes the builder and constructs an Operation<[`GetDirectThread`](crate::operation::GetDirectThread)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetDirectThread, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetDirectThreadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.identity_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_1, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/thread",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetDirectThreadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetDirectThread::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetDirectThread",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetDirectThreadInput`](crate::input::GetDirectThreadInput)
	pub fn builder() -> crate::input::get_direct_thread_input::Builder {
		crate::input::get_direct_thread_input::Builder::default()
	}
}

/// See [`GetThreadHistoryInput`](crate::input::GetThreadHistoryInput)
pub mod get_thread_history_input {
	/// A builder for [`GetThreadHistoryInput`](crate::input::GetThreadHistoryInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) thread_id: std::option::Option<std::string::String>,
		pub(crate) ts: std::option::Option<aws_smithy_types::DateTime>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) query_direction: std::option::Option<crate::model::QueryDirection>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.thread_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.thread_id = input;
			self
		}
		/// RFC3339 timestamp.
		pub fn ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.ts = Some(input);
			self
		}
		/// RFC3339 timestamp.
		pub fn set_ts(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
			self.ts = input;
			self
		}
		/// How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// Represents which direction to query messages from relative to the given timestamp.
		pub fn query_direction(mut self, input: crate::model::QueryDirection) -> Self {
			self.query_direction = Some(input);
			self
		}
		/// Represents which direction to query messages from relative to the given timestamp.
		pub fn set_query_direction(
			mut self,
			input: std::option::Option<crate::model::QueryDirection>,
		) -> Self {
			self.query_direction = input;
			self
		}
		/// Consumes the builder and constructs a [`GetThreadHistoryInput`](crate::input::GetThreadHistoryInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetThreadHistoryInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetThreadHistoryInput {
				thread_id: self.thread_id,
				ts: self.ts,
				count: self.count,
				query_direction: self.query_direction,
			})
		}
	}
}
#[doc(hidden)]
pub type GetThreadHistoryInputOperationOutputAlias = crate::operation::GetThreadHistory;
#[doc(hidden)]
pub type GetThreadHistoryInputOperationRetryAlias = ();
impl GetThreadHistoryInput {
	/// Consumes the builder and constructs an Operation<[`GetThreadHistory`](crate::operation::GetThreadHistory)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetThreadHistory, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetThreadHistoryInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_2 = &_input.thread_id;
				let input_2 = input_2.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					},
				)?;
				let thread_id = aws_smithy_http::label::fmt_string(input_2, false);
				if thread_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/threads/{thread_id}/history",
					thread_id = thread_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetThreadHistoryInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_3) = &_input.ts {
					query.push_kv(
						"ts",
						&aws_smithy_http::query::fmt_timestamp(
							inner_3,
							aws_smithy_types::date_time::Format::DateTime,
						)?,
					);
				}
				if let Some(inner_4) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_4).encode(),
					);
				}
				if let Some(inner_5) = &_input.query_direction {
					query.push_kv(
						"query_direction",
						&aws_smithy_http::query::fmt_string(&inner_5),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetThreadHistoryInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetThreadHistory::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetThreadHistory",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetThreadHistoryInput`](crate::input::GetThreadHistoryInput)
	pub fn builder() -> crate::input::get_thread_history_input::Builder {
		crate::input::get_thread_history_input::Builder::default()
	}
}

/// See [`GetThreadTopicInput`](crate::input::GetThreadTopicInput)
pub mod get_thread_topic_input {
	/// A builder for [`GetThreadTopicInput`](crate::input::GetThreadTopicInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) thread_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.thread_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.thread_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetThreadTopicInput`](crate::input::GetThreadTopicInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetThreadTopicInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetThreadTopicInput {
				thread_id: self.thread_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetThreadTopicInputOperationOutputAlias = crate::operation::GetThreadTopic;
#[doc(hidden)]
pub type GetThreadTopicInputOperationRetryAlias = ();
impl GetThreadTopicInput {
	/// Consumes the builder and constructs an Operation<[`GetThreadTopic`](crate::operation::GetThreadTopic)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetThreadTopic, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetThreadTopicInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_6 = &_input.thread_id;
				let input_6 = input_6.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					},
				)?;
				let thread_id = aws_smithy_http::label::fmt_string(input_6, false);
				if thread_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/threads/{thread_id}/topic", thread_id = thread_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetThreadTopicInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetThreadTopic::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetThreadTopic",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetThreadTopicInput`](crate::input::GetThreadTopicInput)
	pub fn builder() -> crate::input::get_thread_topic_input::Builder {
		crate::input::get_thread_topic_input::Builder::default()
	}
}

/// See [`SendChatMessageInput`](crate::input::SendChatMessageInput)
pub mod send_chat_message_input {
	/// A builder for [`SendChatMessageInput`](crate::input::SendChatMessageInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) topic: std::option::Option<crate::model::SendChatTopic>,
		pub(crate) message_body: std::option::Option<crate::model::SendMessageBody>,
	}
	impl Builder {
		/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
		pub fn topic(mut self, input: crate::model::SendChatTopic) -> Self {
			self.topic = Some(input);
			self
		}
		/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
		pub fn set_topic(
			mut self,
			input: std::option::Option<crate::model::SendChatTopic>,
		) -> Self {
			self.topic = input;
			self
		}
		/// Data to send in a chat message.
		pub fn message_body(mut self, input: crate::model::SendMessageBody) -> Self {
			self.message_body = Some(input);
			self
		}
		/// Data to send in a chat message.
		pub fn set_message_body(
			mut self,
			input: std::option::Option<crate::model::SendMessageBody>,
		) -> Self {
			self.message_body = input;
			self
		}
		/// Consumes the builder and constructs a [`SendChatMessageInput`](crate::input::SendChatMessageInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SendChatMessageInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SendChatMessageInput {
				topic: self.topic,
				message_body: self.message_body,
			})
		}
	}
}
#[doc(hidden)]
pub type SendChatMessageInputOperationOutputAlias = crate::operation::SendChatMessage;
#[doc(hidden)]
pub type SendChatMessageInputOperationRetryAlias = ();
impl SendChatMessageInput {
	/// Consumes the builder and constructs an Operation<[`SendChatMessage`](crate::operation::SendChatMessage)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SendChatMessage, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SendChatMessageInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/messages").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SendChatMessageInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_send_chat_message(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SendChatMessage::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SendChatMessage",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SendChatMessageInput`](crate::input::SendChatMessageInput)
	pub fn builder() -> crate::input::send_chat_message_input::Builder {
		crate::input::send_chat_message_input::Builder::default()
	}
}

/// See [`SetThreadReadInput`](crate::input::SetThreadReadInput)
pub mod set_thread_read_input {
	/// A builder for [`SetThreadReadInput`](crate::input::SetThreadReadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) thread_id: std::option::Option<std::string::String>,
		pub(crate) last_read_ts: std::option::Option<aws_smithy_types::DateTime>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.thread_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.thread_id = input;
			self
		}
		/// Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
		pub fn last_read_ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.last_read_ts = Some(input);
			self
		}
		/// Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
		pub fn set_last_read_ts(
			mut self,
			input: std::option::Option<aws_smithy_types::DateTime>,
		) -> Self {
			self.last_read_ts = input;
			self
		}
		/// Consumes the builder and constructs a [`SetThreadReadInput`](crate::input::SetThreadReadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetThreadReadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetThreadReadInput {
				thread_id: self.thread_id,
				last_read_ts: self.last_read_ts,
			})
		}
	}
}
#[doc(hidden)]
pub type SetThreadReadInputOperationOutputAlias = crate::operation::SetThreadRead;
#[doc(hidden)]
pub type SetThreadReadInputOperationRetryAlias = ();
impl SetThreadReadInput {
	/// Consumes the builder and constructs an Operation<[`SetThreadRead`](crate::operation::SetThreadRead)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetThreadRead, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetThreadReadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_7 = &_input.thread_id;
				let input_7 = input_7.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					},
				)?;
				let thread_id = aws_smithy_http::label::fmt_string(input_7, false);
				if thread_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/threads/{thread_id}/read", thread_id = thread_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetThreadReadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_thread_read(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetThreadRead::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetThreadRead",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetThreadReadInput`](crate::input::SetThreadReadInput)
	pub fn builder() -> crate::input::set_thread_read_input::Builder {
		crate::input::set_thread_read_input::Builder::default()
	}
}

/// See [`SetTypingStatusInput`](crate::input::SetTypingStatusInput)
pub mod set_typing_status_input {
	/// A builder for [`SetTypingStatusInput`](crate::input::SetTypingStatusInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) thread_id: std::option::Option<std::string::String>,
		pub(crate) status: std::option::Option<crate::model::ChatTypingStatus>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.thread_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.thread_id = input;
			self
		}
		/// Represents a chat typing status.
		pub fn status(mut self, input: crate::model::ChatTypingStatus) -> Self {
			self.status = Some(input);
			self
		}
		/// Represents a chat typing status.
		pub fn set_status(
			mut self,
			input: std::option::Option<crate::model::ChatTypingStatus>,
		) -> Self {
			self.status = input;
			self
		}
		/// Consumes the builder and constructs a [`SetTypingStatusInput`](crate::input::SetTypingStatusInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetTypingStatusInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetTypingStatusInput {
				thread_id: self.thread_id,
				status: self.status,
			})
		}
	}
}
#[doc(hidden)]
pub type SetTypingStatusInputOperationOutputAlias = crate::operation::SetTypingStatus;
#[doc(hidden)]
pub type SetTypingStatusInputOperationRetryAlias = ();
impl SetTypingStatusInput {
	/// Consumes the builder and constructs an Operation<[`SetTypingStatus`](crate::operation::SetTypingStatus)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetTypingStatus, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetTypingStatusInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_8 = &_input.thread_id;
				let input_8 = input_8.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					},
				)?;
				let thread_id = aws_smithy_http::label::fmt_string(input_8, false);
				if thread_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/threads/{thread_id}/typing-status",
					thread_id = thread_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetTypingStatusInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_typing_status(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetTypingStatus::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetTypingStatus",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetTypingStatusInput`](crate::input::SetTypingStatusInput)
	pub fn builder() -> crate::input::set_typing_status_input::Builder {
		crate::input::set_typing_status_input::Builder::default()
	}
}

/// See [`WatchThreadInput`](crate::input::WatchThreadInput)
pub mod watch_thread_input {
	/// A builder for [`WatchThreadInput`](crate::input::WatchThreadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) thread_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.thread_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.thread_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`WatchThreadInput`](crate::input::WatchThreadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::WatchThreadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::WatchThreadInput {
				thread_id: self.thread_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type WatchThreadInputOperationOutputAlias = crate::operation::WatchThread;
#[doc(hidden)]
pub type WatchThreadInputOperationRetryAlias = ();
impl WatchThreadInput {
	/// Consumes the builder and constructs an Operation<[`WatchThread`](crate::operation::WatchThread)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::WatchThread, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::WatchThreadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_9 = &_input.thread_id;
				let input_9 = input_9.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					},
				)?;
				let thread_id = aws_smithy_http::label::fmt_string(input_9, false);
				if thread_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "thread_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/threads/{thread_id}/live", thread_id = thread_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::WatchThreadInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_10) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_10),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::WatchThreadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::WatchThread::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"WatchThread",
			"ChatService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`WatchThreadInput`](crate::input::WatchThreadInput)
	pub fn builder() -> crate::input::watch_thread_input::Builder {
		crate::input::watch_thread_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDirectThreadInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl GetDirectThreadInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for GetDirectThreadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetDirectThreadInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendChatMessageInput {
	/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
	pub topic: std::option::Option<crate::model::SendChatTopic>,
	/// Data to send in a chat message.
	pub message_body: std::option::Option<crate::model::SendMessageBody>,
}
impl SendChatMessageInput {
	/// Topic to send a chat message to. If you already know the thread ID, use `thread_id`.
	pub fn topic(&self) -> std::option::Option<&crate::model::SendChatTopic> {
		self.topic.as_ref()
	}
	/// Data to send in a chat message.
	pub fn message_body(&self) -> std::option::Option<&crate::model::SendMessageBody> {
		self.message_body.as_ref()
	}
}
impl std::fmt::Debug for SendChatMessageInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SendChatMessageInput");
		formatter.field("topic", &self.topic);
		formatter.field("message_body", &self.message_body);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetTypingStatusInput {
	/// A universally unique identifier.
	pub thread_id: std::option::Option<std::string::String>,
	/// Represents a chat typing status.
	pub status: std::option::Option<crate::model::ChatTypingStatus>,
}
impl SetTypingStatusInput {
	/// A universally unique identifier.
	pub fn thread_id(&self) -> std::option::Option<&str> {
		self.thread_id.as_deref()
	}
	/// Represents a chat typing status.
	pub fn status(&self) -> std::option::Option<&crate::model::ChatTypingStatus> {
		self.status.as_ref()
	}
}
impl std::fmt::Debug for SetTypingStatusInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetTypingStatusInput");
		formatter.field("thread_id", &self.thread_id);
		formatter.field("status", &self.status);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetThreadReadInput {
	/// A universally unique identifier.
	pub thread_id: std::option::Option<std::string::String>,
	/// Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
	pub last_read_ts: std::option::Option<aws_smithy_types::DateTime>,
}
impl SetThreadReadInput {
	/// A universally unique identifier.
	pub fn thread_id(&self) -> std::option::Option<&str> {
		self.thread_id.as_deref()
	}
	/// Any messages newer than this timestamp will be marked as unread. This should be the current timestamp (in milliseconds).
	pub fn last_read_ts(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
		self.last_read_ts.as_ref()
	}
}
impl std::fmt::Debug for SetThreadReadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetThreadReadInput");
		formatter.field("thread_id", &self.thread_id);
		formatter.field("last_read_ts", &self.last_read_ts);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetThreadHistoryInput {
	/// A universally unique identifier.
	pub thread_id: std::option::Option<std::string::String>,
	/// RFC3339 timestamp.
	pub ts: std::option::Option<aws_smithy_types::DateTime>,
	/// How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
	pub count: std::option::Option<i32>,
	/// Represents which direction to query messages from relative to the given timestamp.
	pub query_direction: std::option::Option<crate::model::QueryDirection>,
}
impl GetThreadHistoryInput {
	/// A universally unique identifier.
	pub fn thread_id(&self) -> std::option::Option<&str> {
		self.thread_id.as_deref()
	}
	/// RFC3339 timestamp.
	pub fn ts(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
		self.ts.as_ref()
	}
	/// How many messages to collect in each direction. If querying `rivet.api.chat.common#QueryDirection$before_and_after`, `rivet.api.chat.common#QueryDirection$chat_messages` will be `count * 2`.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// Represents which direction to query messages from relative to the given timestamp.
	pub fn query_direction(&self) -> std::option::Option<&crate::model::QueryDirection> {
		self.query_direction.as_ref()
	}
}
impl std::fmt::Debug for GetThreadHistoryInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetThreadHistoryInput");
		formatter.field("thread_id", &self.thread_id);
		formatter.field("ts", &self.ts);
		formatter.field("count", &self.count);
		formatter.field("query_direction", &self.query_direction);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WatchThreadInput {
	/// A universally unique identifier.
	pub thread_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl WatchThreadInput {
	/// A universally unique identifier.
	pub fn thread_id(&self) -> std::option::Option<&str> {
		self.thread_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for WatchThreadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("WatchThreadInput");
		formatter.field("thread_id", &self.thread_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetThreadTopicInput {
	/// A universally unique identifier.
	pub thread_id: std::option::Option<std::string::String>,
}
impl GetThreadTopicInput {
	/// A universally unique identifier.
	pub fn thread_id(&self) -> std::option::Option<&str> {
		self.thread_id.as_deref()
	}
}
impl std::fmt::Debug for GetThreadTopicInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetThreadTopicInput");
		formatter.field("thread_id", &self.thread_id);
		formatter.finish()
	}
}
