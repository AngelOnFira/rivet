// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_direct_thread_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDirectThreadOutput, crate::error::GetDirectThreadError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetDirectThreadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetDirectThreadError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetDirectThreadError {
			meta: generic,
			kind: crate::error::GetDirectThreadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetDirectThreadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetDirectThreadError {
				meta: generic,
				kind: crate::error::GetDirectThreadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDirectThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetDirectThreadError {
				meta: generic,
				kind: crate::error::GetDirectThreadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDirectThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetDirectThreadError {
				meta: generic,
				kind: crate::error::GetDirectThreadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDirectThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetDirectThreadError {
				meta: generic,
				kind: crate::error::GetDirectThreadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDirectThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetDirectThreadError {
				meta: generic,
				kind: crate::error::GetDirectThreadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetDirectThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetDirectThreadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_direct_thread_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDirectThreadOutput, crate::error::GetDirectThreadError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_direct_thread_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_direct_thread(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetDirectThreadError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_thread_history_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetThreadHistoryOutput, crate::error::GetThreadHistoryError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetThreadHistoryError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetThreadHistoryError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetThreadHistoryError {
			meta: generic,
			kind: crate::error::GetThreadHistoryErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetThreadHistoryError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetThreadHistoryError {
				meta: generic,
				kind: crate::error::GetThreadHistoryErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetThreadHistoryError {
				meta: generic,
				kind: crate::error::GetThreadHistoryErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetThreadHistoryError {
				meta: generic,
				kind: crate::error::GetThreadHistoryErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetThreadHistoryError {
				meta: generic,
				kind: crate::error::GetThreadHistoryErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetThreadHistoryError {
				meta: generic,
				kind: crate::error::GetThreadHistoryErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetThreadHistoryError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_thread_history_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetThreadHistoryOutput, crate::error::GetThreadHistoryError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_thread_history_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_thread_history(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetThreadHistoryError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_thread_topic_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetThreadTopicOutput, crate::error::GetThreadTopicError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetThreadTopicError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetThreadTopicError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetThreadTopicError {
			meta: generic,
			kind: crate::error::GetThreadTopicErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetThreadTopicError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetThreadTopicError {
				meta: generic,
				kind: crate::error::GetThreadTopicErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadTopicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetThreadTopicError {
				meta: generic,
				kind: crate::error::GetThreadTopicErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadTopicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetThreadTopicError {
				meta: generic,
				kind: crate::error::GetThreadTopicErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadTopicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetThreadTopicError {
				meta: generic,
				kind: crate::error::GetThreadTopicErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadTopicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetThreadTopicError {
				meta: generic,
				kind: crate::error::GetThreadTopicErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetThreadTopicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetThreadTopicError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_thread_topic_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetThreadTopicOutput, crate::error::GetThreadTopicError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_thread_topic_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_thread_topic(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetThreadTopicError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_chat_message_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendChatMessageOutput, crate::error::SendChatMessageError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SendChatMessageError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SendChatMessageError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SendChatMessageError {
			meta: generic,
			kind: crate::error::SendChatMessageErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SendChatMessageError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SendChatMessageError {
				meta: generic,
				kind: crate::error::SendChatMessageErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendChatMessageError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SendChatMessageError {
				meta: generic,
				kind: crate::error::SendChatMessageErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendChatMessageError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SendChatMessageError {
				meta: generic,
				kind: crate::error::SendChatMessageErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendChatMessageError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SendChatMessageError {
				meta: generic,
				kind: crate::error::SendChatMessageErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendChatMessageError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SendChatMessageError {
				meta: generic,
				kind: crate::error::SendChatMessageErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SendChatMessageError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SendChatMessageError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_chat_message_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendChatMessageOutput, crate::error::SendChatMessageError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::send_chat_message_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_send_chat_message(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::SendChatMessageError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_thread_read_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetThreadReadOutput, crate::error::SetThreadReadError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SetThreadReadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SetThreadReadError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SetThreadReadError {
			meta: generic,
			kind: crate::error::SetThreadReadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SetThreadReadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SetThreadReadError {
				meta: generic,
				kind: crate::error::SetThreadReadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetThreadReadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SetThreadReadError {
				meta: generic,
				kind: crate::error::SetThreadReadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetThreadReadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SetThreadReadError {
				meta: generic,
				kind: crate::error::SetThreadReadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetThreadReadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SetThreadReadError {
				meta: generic,
				kind: crate::error::SetThreadReadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetThreadReadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SetThreadReadError {
				meta: generic,
				kind: crate::error::SetThreadReadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetThreadReadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SetThreadReadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_thread_read_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetThreadReadOutput, crate::error::SetThreadReadError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::set_thread_read_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_typing_status_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetTypingStatusOutput, crate::error::SetTypingStatusError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SetTypingStatusError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SetTypingStatusError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SetTypingStatusError {
			meta: generic,
			kind: crate::error::SetTypingStatusErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SetTypingStatusError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SetTypingStatusError {
				meta: generic,
				kind: crate::error::SetTypingStatusErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetTypingStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SetTypingStatusError {
				meta: generic,
				kind: crate::error::SetTypingStatusErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetTypingStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SetTypingStatusError {
				meta: generic,
				kind: crate::error::SetTypingStatusErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetTypingStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SetTypingStatusError {
				meta: generic,
				kind: crate::error::SetTypingStatusErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetTypingStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SetTypingStatusError {
				meta: generic,
				kind: crate::error::SetTypingStatusErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetTypingStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SetTypingStatusError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_typing_status_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetTypingStatusOutput, crate::error::SetTypingStatusError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::set_typing_status_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_watch_thread_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::WatchThreadOutput, crate::error::WatchThreadError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::WatchThreadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::WatchThreadError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::WatchThreadError {
			meta: generic,
			kind: crate::error::WatchThreadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::WatchThreadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::WatchThreadError {
				meta: generic,
				kind: crate::error::WatchThreadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::WatchThreadError {
				meta: generic,
				kind: crate::error::WatchThreadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::WatchThreadError {
				meta: generic,
				kind: crate::error::WatchThreadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::WatchThreadError {
				meta: generic,
				kind: crate::error::WatchThreadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::WatchThreadError {
				meta: generic,
				kind: crate::error::WatchThreadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchThreadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::WatchThreadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_watch_thread_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::WatchThreadOutput, crate::error::WatchThreadError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::watch_thread_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_watch_thread(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::WatchThreadError::unhandled)?;
		output.build()
	})
}
